<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Coding Rules</title>

    <link rel="stylesheet" href="css/app.css">
</head>
<body>
    <div id="app"></div>
    <script>
        window.data = {"total":58,"p":1,"ps":500,"rules":[{"key":"common-swift:DuplicatedBlocks","repo":"common-swift","name":"Source files should not have any duplicated blocks","htmlDesc":"An issue is created on a file as soon as there is at least one block of duplicated code on this file","status":"READY","tags":["rank2"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"common-swift:FailedUnitTests","repo":"common-swift","name":"Failed unit tests should be fixed","htmlDesc":"Test failures or errors generally indicate that regressions have been introduced. Those tests should be handled as soon as possible to reduce the cost to fix the corresponding regressions.","status":"READY","tags":["rank5"],"langName":"Swift","params":[],"type":"BUG"},{"key":"common-swift:SkippedUnitTests","repo":"common-swift","name":"Skipped unit tests should be either removed or fixed","htmlDesc":"Skipped unit tests are considered as dead code. Either they should be activated again (and updated) or they should be removed.","status":"READY","tags":["rank5"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S100","repo":"swift","name":"Function names should comply with a naming convention","htmlDesc":"<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.<\/p>","status":"READY","tags":["rank1"],"langName":"Swift","params":[{"key":"format","htmlDesc":"Regular expression used to check the function names against","defaultValue":"^[a-z][a-zA-Z0-9]*$","type":"STRING"}],"type":"CODE_SMELL"},{"key":"swift:S101","repo":"swift","name":"Class names should comply with a naming convention","htmlDesc":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all class\nnames match a provided regular expression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With default provided regular expression <code>^[A-Z][a-zA-Z0-9]*$<\/code>:<\/p>\n<pre>\nclass my_class {...}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nclass MyClass {...}\n<\/pre>","status":"READY","tags":["rank1"],"langName":"Swift","params":[{"key":"format","htmlDesc":"Regular expression used to check the class names against","defaultValue":"^[A-Z][a-zA-Z0-9]*$","type":"STRING"}],"type":"CODE_SMELL"},{"key":"swift:S103","repo":"swift","name":"Lines should not be too long","htmlDesc":"<p>Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.<\/p>","status":"READY","tags":["rank4"],"langName":"Swift","params":[{"key":"maximumLineLength","htmlDesc":"The maximum authorized line length.","defaultValue":"120","type":"INTEGER"}],"type":"CODE_SMELL"},{"key":"swift:S1066","repo":"swift","name":"Collapsible \"if\" statements should be merged","htmlDesc":"<p>Merging collapsible <code>if<\/code> statements increases the code's readability.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif condition1 {\n  if condition2 {\n    doSomething()\n  }\n}\n\nif let y = someOptional {\n  if x &gt; 0 {\n    doSomething()\n  }\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif condition1 &amp;&amp; condition2 {\n  doSomething()\n}\n\nif let y = someOptional where x &gt; 0 {\n  doSomething()\n}\n\nif x &gt; 0, let y = someOptional {\n  doSomething()\n}\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1075","repo":"swift","name":"URIs should not be hardcoded","htmlDesc":"<p>Hard coding a URI makes it difficult to test a program: path literals are not always portable across operating systems, a given absolute path may\nnot exist on a specific test environment, a specified Internet URL may not be available when executing the tests, production environment filesystems\nusually differ from the development environment, ...etc. For all those reasons, a URI should never be hard coded. Instead, it should be replaced by\ncustomizable parameter.<\/p>\n<p>Further even if the elements of a URI are obtained dynamically, portability can still be limited if the path-delimiters are hard-coded.<\/p>\n<p>This rule raises an issue when URI's or path delimiters are hard coded.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\npublic class Foo {\n    public func listUsers() -&gt; [User] {\n        var users:[User]\n        let location = \"\/home\/mylogin\/Dev\/users.txt\"     \/\/ Non-Compliant\n        let fileContent = NSString(contentsOfFile: location, encoding: NSUTF8StringEncoding, error: nil)\n        users = parse(fileContent!)\n        return users\n    }\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\npublic class Foo {\n    \/\/ Configuration is a class that returns customizable properties: it can be mocked to be injected during tests.\n    private var config:Configuration\n    public init(myConfig:Configuration) {\n        config = myConfig\n    }\n    public func listUsers() -&gt; [User] {\n        var users:[User]\n        \/\/ Find here the way to get the correct folder, in this case using the Configuration object\n        let location = config.getProperty(\"myApplication.listingFile\")\n        \/\/ and use this parameter instead of the hard coded path\n        let fileContent = NSString(contentsOfFile: location, encoding: NSUTF8StringEncoding, error: nil)\n        users = parse(fileContent!)\n        return users\n    }\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/qQCHAQ\">CERT, MSC03-J.<\/a> - Never hard code sensitive information <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1105","repo":"swift","name":"An open curly brace should be located at the end of a line","htmlDesc":"<p>Sharing some coding conventions is a key point to make it possible for a team to efficiently collaborate. This rule makes it mandatory to place\nopen curly braces at the end of lines of code.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif condition\n{\n  doSomething()\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif condition {\n  doSomething()\n}\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>Closure and inlined blocks (left and right curly braces on the same line) are ignored by this rule. <\/p>\n<pre>\nif condition {doSomething()} \/\/ Compliant\nreversed = sorted(\n    names,\n    { (s1: String, s2: String) -&gt; Bool in  \/\/ Compliant\n        return s1 &gt; s2\n    })\n<\/pre>","status":"READY","tags":["rank3"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1109","repo":"swift","name":"A close curly brace should be located at the beginning of a line","htmlDesc":"<p>Shared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the\nbeginning of a line.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif condition {\n  doSomething()}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif condition {\n  doSomething()\n}\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>When blocks are inlined (open and close curly braces on the same line), no issue is triggered.<\/p>\n<pre>\nif condition {doSomething()}\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1110","repo":"swift","name":"Redundant pairs of parentheses should be removed","htmlDesc":"<p>Useless parentheses can sometimes be misleading and so should be removed. <\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nreturn ((x + 1))       \/\/ Noncompliant\nvar x = ((y \/ 2 + 1))  \/\/ Noncompliant\nif ((x &gt; 0)) { ... }   \/\/ Noncompliant\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nreturn (x + 1)\nreturn x + 1\nvar x = (y \/ 2 + 1)\nvar x = y \/ 2 + 1\nif (x &gt; 0) { ... }\nif x &gt; 0 { ... }\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1117","repo":"swift","name":"Local variables should not have the same name as fields or \"enum\" cases","htmlDesc":"<p>Shadowing fields or <code>enum<\/code> <code>case<\/code>s with a local variable is a bad practice that reduces code readability: It makes it\nconfusing to know whether the field or the variable is being used.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\npublic class Foo {\n  public var myField:Int = 0\n\n  public func doSomething() {\n    var myField = 0\n    ...\n  }\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/2ADEAw\">CERT, DCL51-J.<\/a> - Do not shadow or obscure identifiers in subscopes <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1133","repo":"swift","name":"Deprecated code should be removed","htmlDesc":"<p>This rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed.<\/p>\n<p>The following code illustrates this rule:<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\npublic class Foo {\n\n  @availability(*, deprecated=1.1)   \/\/ Noncompliant\n  public func bar() {\n  }\n\n  @availability(*, obsoleted=1.1)  \/\/ Noncompliant\n  public func baz() {\n  }\n}\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S114","repo":"swift","name":"Protocol names should comply with a naming convention","htmlDesc":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all\nprotocol names match a provided regular expression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the default regular expression <code>^[A-Z][a-zA-Z0-9]*$<\/code>:<\/p>\n<pre>\npublic protocol myProtocol {...} \/\/ Noncompliant\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\npublic protocol MyProtocol {...}\n<\/pre>","status":"READY","tags":["rank1"],"langName":"Swift","params":[{"key":"format","htmlDesc":"Regular expression used to check the protocol names against","defaultValue":"^[A-Z][a-zA-Z0-9]*$","type":"STRING"}],"type":"CODE_SMELL"},{"key":"swift:S1144","repo":"swift","name":"Unused \"private\" functions should be removed","htmlDesc":"<p><code>private<\/code> methods that are never executed are dead code: unnecessary, inoperative code that should be removed. Cleaning out dead code\ndecreases the size of the maintained codebase, making it easier to understand the program and preventing bugs from being introduced.<\/p>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/OYIyAQ\">CERT, MSC07-CPP.<\/a> - Detect and remove dead code <\/li>\n<\/ul>","status":"READY","tags":["rank4"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S115","repo":"swift","name":"Constant names should comply with a naming convention","htmlDesc":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all constant names match a provided regular expression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the default regular expression <code>^[a-z][a-zA-Z0-9]*$<\/code>:<\/p>\n<pre>\nlet Pi = 3.14\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nlet pi = 3.14\n<\/pre>","status":"READY","tags":["rank1"],"langName":"Swift","params":[{"key":"format","htmlDesc":"Regular expression used to check the constant names against.","defaultValue":"^[a-z][a-zA-Z0-9]*$","type":"STRING"}],"type":"CODE_SMELL"},{"key":"swift:S116","repo":"swift","name":"Field names should comply with a naming convention","htmlDesc":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that field\nnames match a provided regular expression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the default regular expression <code>^[a-z][a-zA-Z0-9]*$<\/code>:<\/p>\n<pre>\nclass MyClass {\n  var MyField = 1\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nclass MyClass {\n  var myField = 1\n}\n<\/pre>","status":"READY","tags":["rank1"],"langName":"Swift","params":[{"key":"format","htmlDesc":"Regular expression used to check the field names against.","defaultValue":"^[a-z][a-zA-Z0-9]*$","type":"STRING"}],"type":"CODE_SMELL"},{"key":"swift:S117","repo":"swift","name":"Local variable and function parameter names should comply with a naming convention","htmlDesc":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all local\nvariable and function parameter names match a provided regular expression.<\/p>","status":"READY","tags":["rank1"],"langName":"Swift","params":[{"key":"format","htmlDesc":"Regular expression used to check the names against.","defaultValue":"^[a-z][a-zA-Z0-9]*$","type":"STRING"}],"type":"CODE_SMELL"},{"key":"swift:S1172","repo":"swift","name":"Unused function parameters should be removed","htmlDesc":"<p>Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfunc doSomething(a: Int, b: Int) {     \/\/ \"b\" is unused\n  compute(a)\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvoid doSomething(a: Int) {\n  compute(a)\n}\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>Override methods are excluded.<\/p>\n<pre>\noverride doSomething(a: Int, b: Int) {     \/\/ no issue reported on b\n  compute(a)\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. <\/li>\n  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/NYA5\">CERT, MSC12-C.<\/a> - Detect and remove code that has no effect or is never\n  executed <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/SIIyAQ\">CERT, MSC12-CPP.<\/a> - Detect and remove code that has no effect <\/li>\n<\/ul>","status":"READY","tags":["rank4"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1188","repo":"swift","name":"Closures should not have too many lines","htmlDesc":"<p>Closures are a very convenient and compact way to inject a behaviour without having to create a dedicated function. But those closures should be\nused only if the behaviour to be injected can be defined in a few lines of code, otherwise the source code can quickly become unreadable.<\/p>","status":"READY","tags":["rank5"],"langName":"Swift","params":[{"key":"max","htmlDesc":"Maximum allowed lines in a closure","defaultValue":"20","type":"INTEGER"}],"type":"CODE_SMELL"},{"key":"swift:S119","repo":"swift","name":"Type parameter names should comply with a naming convention","htmlDesc":"<p>Shared naming conventions make it possible for a team to collaborate efficiently. Following the established convention of single-letter type\nparameter names helps users and maintainers of your code quickly see the difference between a type parameter and a poorly named class.<\/p>\n<p>This rule check that all type parameter names match a provided regular expression. The following code snippets use the default regular\nexpression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the default regular expression <code>^[A-Z]$<\/code>:<\/p>\n<pre>\npublic class MyClass&lt;TYPE&gt; {    \/\/ Noncompliant\n  func method&lt;TYPE&gt;(t : TYPE) { \/\/ Noncompliant\n  }\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\npublic class MyClass&lt;T&gt; {\n  func method&lt;T&gt;(t : T) {\n  }\n}\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Swift","params":[{"key":"format","htmlDesc":"Regular expression used to check the type parameter names against.","defaultValue":"^[A-Z]$","type":"STRING"}],"type":"CODE_SMELL"},{"key":"swift:S122","repo":"swift","name":"Statements should be on separate lines","htmlDesc":"<p>For better readability, do not put more than one statement on a single line.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif someCondition { doSomething()}\n...\nvar result = doSomething(); return result\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif someCondition {\n  doSomething()\n}\n...\nvar result = doSomething()\nreturn result\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>Variable declaration with initialising code block and closure expressions containing a single statement are ignored.<\/p>\n<pre>\nvar x : Int { return 0 }                                       \/\/ Variable declaration with initialising code block\ndoSomething({ (x: Int, y: Int) -&gt; Bool in return x &gt; y }, 5)   \/\/ Closure expression\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1244","repo":"swift","name":"Floating point numbers should not be tested for equality","htmlDesc":"<p>Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a <code>Float<\/code> or a <code>Double<\/code> through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.<\/p>\n<p>Even simple floating point assignments are not simple:<\/p>\n<pre>\nvar f: Float = 0.1 \/\/ 0.1000000014901161193847656\nvar d: Double = 0.1 \/\/ 0.1000000000000000055511151\n<\/pre>\n<p>Therefore, the use of the equality (<code>==<\/code>) and inequality (<code>!=<\/code>) operators on <code>Float<\/code> or <code>Double<\/code> values\nis almost always an error. <\/p>\n<p>This rule checks for the use of direct and indirect equality\/inequailty tests on floats and doubles.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvar myNumber: Float = 0.3 + 0.6\n\nif myNumber == 0.9 { \/\/ Noncompliant. Because of floating point imprecision, this will be false\n    \/\/ ...\n}\n\nif myNumber &lt;= 0.9 &amp;&amp; myNumber &gt;= 0.9 { \/\/ Noncompliant indirect equality test\n  \/\/ ...\n}\n\nif myNumber &lt; 0.9 || myNumber &gt; 0.9 { \/\/ Noncompliant indirect inequality test\n  \/\/ ...\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality. <\/li>\n  <li> MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality <\/li>\n<\/ul>","status":"READY","tags":["rank1"],"langName":"Swift","params":[],"type":"BUG"},{"key":"swift:S126","repo":"swift","name":"\"if ... else if\" constructs should end with \"else\" clauses","htmlDesc":"<p>This rule applies whenever an <code>if<\/code> statement is followed by one or more <code>else if<\/code> statements; the final <code>else if<\/code>\nshould be followed by an <code>else<\/code> statement.<\/p>\n<p>The requirement for a final <code>else<\/code> statement is defensive programming.<\/p>\n<p>The <code>else<\/code> statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is\nconsistent with the requirement to have a final <code>default<\/code> clause in a <code>switch<\/code> statement.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif x == 0 {\n  doSomething()\n} else if x == 1 {\n  doSomethingElse()\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif x == 0 {\n  doSomething()\n} else if x == 1 {\n  doSomethingElse()\n} else {\n  NSException(name:\"IllegalStateException\", reason:\"Unreachable else clause is reached\", userInfo:nil).raise()\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 14.10 - All if...else if constructs shall be terminated with an else clause. <\/li>\n  <li> MISRA C++:2008, 6-4-2 - All if...else if constructs shall be terminated with an else clause. <\/li>\n  <li> MISRA C:2012, 15.7 - All if...else if constructs shall be terminated with an else statement <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/YgE\">CERT, MSC01-C.<\/a> - Strive for logical completeness <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/JoIyAQ\">CERT, MSC01-CPP.<\/a> - Strive for logical completeness <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/PQHRAw\">CERT, MSC57-J.<\/a> - Strive for logical completeness <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1301","repo":"swift","name":"\"switch\" statements should have at least 3 \"case\" clauses","htmlDesc":"<p><code>switch<\/code> statements are useful when there are many different cases depending on the value of the same expression.<\/p>\n<p>For just one or two cases however, the code will be more readable with <code>if<\/code> statements.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nswitch (variable) {\n  case 0:\n    doSomething();\n  default:\n    doSomethingElse();\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif (variable == 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 15.5 - Every switch statement shall have at least one case clause. <\/li>\n  <li> MISRA C++:2008, 6-4-8 - Every switch statement shall have at least one case-clause. <\/li>\n  <li> MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses <\/li>\n<\/ul>","status":"READY","tags":["rank4"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1313","repo":"swift","name":"IP addresses should not be hardcoded","htmlDesc":"<p>Hardcoding an IP address into source code is a bad idea for several reasons:<\/p>\n<ul>\n  <li> a recompile is required if the address changes <\/li>\n  <li> it forces the same address to be used in every environment (dev, sys, qa, prod) <\/li>\n  <li> it places the responsibility of setting the value to use in production on the shoulders of the developer <\/li>\n  <li> it allows attackers to decompile the code and thereby discover a potentially sensitive address <\/li>\n<\/ul>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvar host : NSHost = NSHost(address: \"127.0.0.1\")\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvar host : NSHost = NSHost(address: configuration.ipAddress)\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/qQCHAQ\">CERT, MSC03-J.<\/a> - Never hard code sensitive information <\/li>\n<\/ul>","status":"READY","tags":["rank4"],"langName":"Swift","params":[],"type":"VULNERABILITY"},{"key":"swift:S134","repo":"swift","name":"Control flow statements \"if\", \"for\", \"for in\", \"while\", \"do while\" and \"switch\" should not be nested too deeply","htmlDesc":"<p>Nested <code>if<\/code>, <code>for<\/code>, <code>for in<\/code>, <code>while<\/code>, <code>do while<\/code> and <code>switch<\/code> statements are a\nkey ingredient for making what's known as \"Spaghetti code\".<\/p>\n<p>Such code is hard to read, refactor and therefore maintain.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the default threshold of 3:<\/p>\n<pre>\n  if condition1 {                  \/\/ Compliant - depth = 1\n    \/* ... *\/\n    if condition2 {                \/\/ Compliant - depth = 2\n      \/* ... *\/\n      for var i = 0; i &lt; 10; i++ {  \/\/ Compliant - depth = 3, not exceeding the limit\n        \/* ... *\/\n        if condition4 {            \/\/ Non-Compliant - depth = 4\n          if condition5 {          \/\/ Depth = 5, exceeding the limit, but issues are only reported on depth = 4\n            \/* ... *\/\n          }\n        }\n      }\n    }\n  }\n<\/pre>","status":"READY","tags":["rank3"],"langName":"Swift","params":[{"key":"max","htmlDesc":"Maximum allowed control flow statement nesting depth.","defaultValue":"3","type":"INTEGER"}],"type":"CODE_SMELL"},{"key":"swift:S139","repo":"swift","name":"Comments should not be located at the end of lines of code","htmlDesc":"<p>This rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvar a1 = b + c \/\/ This is a trailing comment that can be very very long\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\n\/\/ This very long comment is better placed before the line of code\nvar a2 = b + c\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Swift","params":[{"key":"legalTrailingCommentPattern","htmlDesc":"Pattern for text of trailing comments that are allowed. By default, comments containing only one word.","defaultValue":"^\/\/\\s*+[^\\s]++$","type":"STRING"}],"type":"CODE_SMELL"},{"key":"swift:S1481","repo":"swift","name":"Unused local variables should be removed","htmlDesc":"<p>If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will\nnot wonder what the variable is used for.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\npublic func numberOfMinutes(hours:Int) -&gt; Int {\n  var seconds = 0   \/\/ seconds is never used\n  return hours * 60;\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\npublic func numberOfMinutes(hours:Int) -&gt; Int{\n  return hours * 60\n}\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>Simple <code>for-in<\/code> loop counters are ignored by this rule because while they are often legitimately unused, their declaration is required\nby the syntax.<\/p>\n<pre>\nfor i in 1...10 {  \/\/ Ignored\n  print(\"Hello! \");\n}\n\nfor (a, b) in someElements {  \/\/ Noncompliant; b unused\n  print(a)\n}\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1642","repo":"swift","name":"\"struct\" names should comply with a naming convention","htmlDesc":"<p>Sharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all <code>struct<\/code> names match a provided\nregular expression.<\/p>\n<p>Using the default regular expression: \"^[A-Z][a-zA-Z0-9]*$\"<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nstruct my_struct {\n    var one : Int\n    var two : Int\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nstruct MyStruct {\n    var one : Int\n    var two : Int\n}\n<\/pre>","status":"READY","tags":["rank1"],"langName":"Swift","params":[{"key":"format","htmlDesc":"Regular expression <code>struct<\/code> names should match.","defaultValue":"^[A-Z][a-zA-Z0-9]*$","type":"STRING"}],"type":"CODE_SMELL"},{"key":"swift:S1751","repo":"swift","name":"Jump statements should not be used unconditionally","htmlDesc":"<p>Having an unconditional <code>break<\/code>, <code>return<\/code> in a loop renders it useless; the loop will only execute once and the loop\nstructure itself is simply wasted keystrokes.<\/p>\n<p>Having an unconditional <code>continue<\/code> in a loop can render the loop meaningless, or is itself wasted keystrokes, depending on where in the\nloop it occurs.<\/p>\n<p>Having an unconditional <code>return<\/code> anywhere other than at the end of a function or method simply renders all the rest of the code in the\nmethod useless.<\/p>\n<p>For these reasons, unconditional jump statements should never be used except for the final <code>return<\/code> in a function.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvar i:Int\nfor (i = 0; i &lt; 10; ++i) {\n    print(\"i is \\(i)\")\n    break  \/\/ loop only executes once\n}\n\nfor (i = 0; i &lt; 10; ++i) {\n    continue\n    print(\"i is \\(i)\")  \/\/ this is never executed\n}\n\nfor (i = 0; i &lt; 10; ++i) {\n    print(\"i is \\(i)\")\n    continue  \/\/ this is meaningless; the loop would continue anyway\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvar i:Int\nfor (i = 0; i &lt; 10; ++i){\n    print(\"i is \\(i)\")\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code. <\/li>\n  <li> MISRA C++:2008, 0-1-1 - A <em>project<\/em> shall not contain <em>unreachable code<\/em>. <\/li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code. <\/li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/NYA5\">CERT, MSC12-C<\/a> - Detect and remove code that has no effect <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/SIIyAQ\">CERT, MSC12-CPP<\/a> - Detect and remove code that has no effect <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Swift","params":[],"type":"BUG"},{"key":"swift:S1763","repo":"swift","name":"Jump statements should not be followed by other statements","htmlDesc":"<p>Jump statements (<code>return<\/code>, <code>break<\/code>, <code>continue<\/code>, and <code>fallthrough<\/code>) move control flow out of the current\ncode block. Typically, any statements in a block that come after a jump are simply wasted keystrokes lying in wait to confuse the unwary. <\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfunc fun(a:Int)-&gt;Int{\n  var i = 10;\n  return i + a;\n  i++;             \/\/ this is never executed\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nfunc fun(a:Int)-&gt;Int{\n  var i = 10;\n  return i + a;\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code <\/li>\n  <li> MISRA C++:2008, 0-1-1 - A project shall not contain unreachable code <\/li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code <\/li>\n  <li> MISRA C:2012, 2.1 - A project shall not contain unreachable code <\/li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code <\/li>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/561.html\">MITRE, CWE-561<\/a> - Dead Code <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/uQCSBg\">CERT, MSC56-J.<\/a> - Detect and remove superfluous code and values <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/NYA5\">CERT, MSC12-C.<\/a> - Detect and remove code that has no effect or is never\n  executed <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/OYIyAQ\">CERT, MSC07-CPP.<\/a> - Detect and remove dead code <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Swift","params":[],"type":"BUG"},{"key":"swift:S1764","repo":"swift","name":"Identical expressions should not be used on both sides of a binary operator","htmlDesc":"<p>Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy\/paste\nerror and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical\noperators, having the same value on both sides of an operator yields predictable results, and should be simplified.<\/p>\n<p>This rule ignores <code>*<\/code>, <code>+<\/code>. <\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif a == a { \/\/ always true\n  doZ()\n}\nif  a != a  { \/\/ always false\n  doY()\n}\nif a == b &amp;&amp; a == b { \/\/ if the first one is true, the second one is too\n  doX()\n}\nif a == b || a == b { \/\/ if the first one is true, the second one is too\n  doW()\n}\n\nvar j = 5 \/ 5 \/\/always 1\nvar k = 5 - 5 \/\/always 0\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>Left-shifting 1 onto 1 is common in the construction of bit masks, and is ignored.<\/p>\n<pre>\nvar i = 1 &lt;&lt; 1; \/\/ Compliant\nvar j = a &lt;&lt; a; \/\/ Noncompliant\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/NYA5\">CERT, MSC12-C<\/a> - Detect and remove code that has no effect <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/SIIyAQ\">CERT, MSC12-CPP<\/a> - Detect and remove code that has no effect. <\/li>\n<\/ul>","status":"READY","tags":["rank5"],"langName":"Swift","params":[],"type":"BUG"},{"key":"swift:S1821","repo":"swift","name":"\"switch\" statements should not be nested","htmlDesc":"<p>Nested <code>switch<\/code> structures are difficult to understand because you can easily confuse the cases of an inner <code>switch<\/code> as\nbelonging to an outer statement. Therefore nested <code>switch<\/code> statements should be avoided.<\/p>\n<p>Specifically, you should structure your code to avoid the need for nested <code>switch<\/code> statements, but if you cannot, then consider moving\nthe inner <code>switch<\/code> to another function.<\/p>","status":"READY","tags":["rank3"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1845","repo":"swift","name":"Methods and field names should not be the same or differ only by capitalization","htmlDesc":"<p>Looking at the set of methods in a <code>class<\/code>, <code>struct<\/code>, <code>enum<\/code>, or <code>extension<\/code> and finding two methods\nthat differ only by capitalization is confusing to users of the class. It is similarly confusing to have a method and a field or a case which differ\nonly in capitalization.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nclass SomeClass {\n    var lookUp = false\n    func lookup(){ }        \/\/ Noncompliant; method name differs from field name only by capitalization\n    func lookUP(){ }        \/\/ Noncompliant; method name differs from field and another method name only by capitalization\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nclass SomeClass {\n    var lookUp = false\n    func getLookUp(){ }\n}\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S1854","repo":"swift","name":"Dead stores should be removed","htmlDesc":"<p>A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value\nonly to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error, it is at best a waste of resources.\nTherefore all calculated values should be used.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfunc calculateRate(a:Int, b:Int) {\n  var i:Int\n\n  i = a + b \/\/ Noncompliant; calculation result not used before value is overwritten\n  i = doSomething()  \/\/ Noncompliant; retrieved value not used\n  for i = 0; i &lt; 10; i++ {\n    \/\/  ...\n  }\n  \/\/ ...\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nfunc calculateRate(a:Int, b:Int) {\n  var i:Int\n\n  i = doSomething()\n  i += a + b\n  storeI(i)\n\n  for i = 0; i &lt; 10; i++ {\n    \/\/  ...\n  }\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/563.html\">MITRE, CWE-563<\/a> - Assignment to Variable without Use ('Unused Variable') <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/QYA5\">CERT, MSC13-C.<\/a> - Detect and remove unused values <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/S4IyAQ\">CERT, MSC13-CPP.<\/a> - Detect and remove unused values <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/uQCSBg\">CERT, MSC56-J.<\/a> - Detect and remove superfluous code and values <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/SIIyAQ\">CERT, MSC12-CPP.<\/a> - Detect and remove code that has no effect <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Swift","params":[],"type":"BUG"},{"key":"swift:S1996","repo":"swift","name":"Types should be defined in separate source files","htmlDesc":"<p>A file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain. This\nis doubly true for a file with multiple independent classes, extensions, protocols, enumerations or structures. It is strongly advised to define each\nindividual type in separate source file.<\/p>\n<h2>Exceptions<\/h2>\n<p>The case when file contains only class and its extensions is ignored.<\/p>\n<pre>\nclass MyViewController: UIViewController {\n  \/\/ class stuff here\n}\n\nextension MyViewController: UITableViewDataSource {\n  \/\/ table view data source methods\n}\n\nextension MyViewController: UIScrollViewDelegate {\n  \/\/ scroll view delegate methods\n}\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S2007","repo":"swift","name":"Functions and variables should not be defined outside of classes","htmlDesc":"<p>Defining and using global variables and global functions, when the convention dictates OOP can be confusing and difficult to use properly for\nmultiple reasons:<\/p>\n<ul>\n  <li> You run the risk of name clashes. <\/li>\n  <li> Global functions must be stateless, or they can cause difficult-to-track bugs. <\/li>\n  <li> Global variables can be updated from anywhere and may no longer hold the value you expect. <\/li>\n  <li> It is difficult to properly test classes that use global functions. <\/li>\n<\/ul>\n<p>Instead of being declared globally, such variables and functions should be moved into a class, potentially marked <code>static<\/code>, so they can\nbe used without a class instance. <\/p>\n<p>This rule checks that only object-oriented programming is used and that no functions or procedures are declared outside of a class.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvar name = \"Bob\"    \/\/ Noncompliant\n\nfunc doSomething() {   \/\/ Noncompliant\n  \/\/...\n}\n\nclass MyClass {\n    \/\/...\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\npublic class MyClass {\n  public static var name = \"Bob\"\n\n  public class func doSomething() {              \/\/ Compliant\n    \/\/...\n  }\n  \/\/...\n}\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>The operator function is a function with a name that matches the operator to be overloaded. Because such functions can only be defined in a global\nscope, they are ignored by this rule.<\/p>\n<pre>\npublic class Vector2D {\n    var x = 0.0, y = 0.0\n    \/\/ ...\n}\n\nfunc + (left: Vector2D, right: Vector2D) -&gt; Vector2D {\n    return Vector2D(x: left.x + right.x, y: left.y + right.y)\n}\n<\/pre>","status":"READY","tags":["rank3"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S2068","repo":"swift","name":"Credentials should not be hard-coded","htmlDesc":"<p>Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they're almost guaranteed to\nend up in the hands of an attacker. This is particularly true for applications that are distributed.<\/p>\n<p>Credentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvar post:NSString = \"username=Steve&amp;password=123456\"  \/\/ Noncompliant\nvar postData:NSData = post.dataUsingEncoding(NSASCIIStringEncoding)!\n\/\/...\nvar request:NSMutableURLRequest = NSMutableURLRequest(URL: url)\nrequest.HTTPBody = postData\n\/\/...\nvar urlData: NSData? = NSURLConnection.sendSynchronousRequest(request, returningResponse:&amp;response, error:&amp;reponseError)\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvar post:NSString = \"username=\\(getEncryptedUser())&amp;password=\\(getEncryptedPass())\"\nvar postData:NSData = post.dataUsingEncoding(NSASCIIStringEncoding)!\n\/\/...\nvar request:NSMutableURLRequest = NSMutableURLRequest(URL: url)\nrequest.HTTPBody = postData\n\/\/...\nvar urlData: NSData? = NSURLConnection.sendSynchronousRequest(request, returningResponse:&amp;response, error:&amp;reponseError)\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/798\">MITRE, CWE-798<\/a> - Use of Hard-coded Credentials <\/li>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/259\">MITRE, CWE-259<\/a> - Use of Hard-coded Password <\/li>\n  <li> <a href=\"http:\/\/www.sans.org\/top25-software-errors\/\">SANS Top 25<\/a> - Porous Defenses <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/qQCHAQ\">CERT, MSC03-J.<\/a> - Never hard code sensitive information <\/li>\n  <li> <a href=\"https:\/\/www.owasp.org\/index.php\/Top_10_2013-A2-Broken_Authentication_and_Session_Management\">OWASP Top Ten 2013 Category A2<\/a> -\n  Broken Authentication and Session Management <\/li>\n  <li> Derived from FindSecBugs rule <a href=\"http:\/\/h3xstream.github.io\/find-sec-bugs\/bugs.htm#HARD_CODE_PASSWORD\">Hard Coded Password<\/a> <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Swift","params":[],"type":"VULNERABILITY"},{"key":"swift:S2108","repo":"swift","name":"Fields and variables that are never updated should be constant","htmlDesc":"<p>Variables that are never updated will always return their default values and so they should be explicitly declared as constant. A\n<code>let<\/code>-declaration guarantees and clearly signals to the programmer that its value is supposed to and will never change.<\/p>\n<p>This rule applies to non-constant fields and variables which are not set within the codebase.<\/p>","status":"READY","tags":["rank1"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S2197","repo":"swift","name":"Modulus results should not be checked for direct equality","htmlDesc":"<p>When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus of a variable for\nequality with a positive number (or a negative one) could result in unexpected results. <\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfunc isOdd(x:Int) -&gt; Bool {\n  return x % 2 == 1  \/\/ Noncompliant; if x is negative, x % 2 == -1\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nfunc isOdd(x:Int) -&gt; Bool {\n  return x % 2 != 0\n}\n<\/pre>\n<p>or<\/p>\n<pre>\nfunc isOdd(x:Int) -&gt; Bool {\n  return abs(x % 2) == 1\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/xAHAAQ\">CERT, NUM51-J.<\/a> - Do not assume that the remainder operator always returns a\n  nonnegative result for integral operands <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/NQBi\">CERT, INT10-C<\/a> - Do not assume a positive remainder when using the % operator\n  <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/_YBLAQ\">CERT, INT10-CPP.<\/a> - Do not assume a positive remainder when using the %\n  operator <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S2342","repo":"swift","name":"Enumeration types should comply with a naming convention","htmlDesc":"<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all <code>enum<\/code> names match a provided regular\nexpression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With default provided regular expression: <code>^[A-Z][a-zA-Z0-9]*<\/code><\/p>\n<pre>\nenum someEnumeration { \/\/ Non-Compliant\n    case Bar\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nenum SomeEnumeration {\n    case Bar\n}\n<\/pre>","status":"READY","tags":["rank1"],"langName":"Swift","params":[{"key":"format","defaultValue":"^[A-Z][a-zA-Z0-9]*$","type":"STRING"}],"type":"CODE_SMELL"},{"key":"swift:S2343","repo":"swift","name":"Enumeration members should comply with a naming convention","htmlDesc":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all enumeration member names match a provided regular\nexpression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With default provided regular expression: <code>^[a-z][a-zA-Z0-9]*$<\/code><\/p>\n<pre>\nenum SomeEnumeration {\n    case SomeMember  \/\/ Non-Compliant\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nenum SomeEnumeration {\n    case someMember\n}\n<\/pre>","status":"READY","tags":["rank1"],"langName":"Swift","params":[{"key":"format","defaultValue":"^[a-z][a-zA-Z0-9]*$","type":"STRING"}],"type":"CODE_SMELL"},{"key":"swift:S2523","repo":"swift","name":"Comments should not be nested","htmlDesc":"<p>Nested comments are confusing and can lead maintainers to misunderstand which code is active.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\n\/*\n  This is a comment block.\n  It may be difficult to figure out that the following line of code is actually commented\n\n\nvariable = function_call();\n\/* variable contains the result. Noncompliant; inner comment *\/\n*\/\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 2.3 - The character sequence \/* shall not be used within a comment. <\/li>\n  <li> MISRA C++:2008, 2-7-1 - The character sequence \/* shall not be used within a C-style comment. <\/li>\n  <li> MISRA C:2012, 3.1 - The character sequences \/* and \/\/ shall not be used within a comment <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/L4IyAQ\">CERT, MSC04-CPP.<\/a> - Use comments consistently and in a readable fashion\n  <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/KgQ\">CERT, MSC04-C.<\/a> - Use comments consistently and in a readable fashion <\/li>\n<\/ul>","status":"READY","tags":["rank5"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S2950","repo":"swift","name":"Access control should be specified for top-level definitions","htmlDesc":"<p>The access level defaults to <code>internal<\/code> if left unspecified. Since that doesn't make sense for most top-level declarations, access\nlevels should always be specified explicitly, even when <code>internal<\/code> is what's intended.<\/p>\n<p>This rule raises an issue when the access level is not specified on any top-level declaration.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nclass Foo {  \/\/ Noncompliant\n  \/\/ ...\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\npublic class Foo {\n  \/\/ ...\n}\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Swift","params":[],"type":"VULNERABILITY"},{"key":"swift:S2951","repo":"swift","name":"\"break\" should be the only statement in a \"case\"","htmlDesc":"<p>Because <code>case<\/code> statements in a Swift <code>switch<\/code> do not fall through, there is no need to use <code>break<\/code> at the end of a\n<code>case<\/code> unless it would otherwise be empty. Since an empty <code>case<\/code> isn't allowed, an explicit <code>break<\/code> is needed to make\nsuch code compilable. There is no other reason to use <code>break<\/code> in a <code>case<\/code>.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nswitch weekday {\n  case sunday:\n    break\n  case monday:\n    getUpEarly()\n    break  \/\/ Noncompliant\n  case tuesday\n    \/\/ ...\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nswitch weekday {\n  case sunday:\n    break\n  case monday:\n    getUpEarly()\n  case tuesday\n    \/\/ ...\n}\n<\/pre>","status":"READY","tags":["rank3"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S2957","repo":"swift","name":"\"return\" should be omitted from single-expression closures","htmlDesc":"<p>When a closure contains only a <code>return<\/code> statement, the <code>return<\/code> itself can be omitted.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nsomeList.sort { a, b in\n  return a &gt; b\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nsomeList.sort { a, b in a &gt; b }\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S2958","repo":"swift","name":"Trailing closure syntax should not be used when multiple parameters are of function type","htmlDesc":"<p>Using trailing closure syntax for the last parameter in a call is often the most elegant way to handle it. But if the call requires multiple\nfunction-type arguments, the use of a trailing closure can be messy and confusing. In such cases, it's better to pass closure expressions as normal\narguments.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvar x = complexOperation(\n  arg: 2,\n  op1: {$0 + 10}\n) {$0 * $0}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvar x = complexOperation(\n  arg: 2,\n  op1: {$0 + 10},\n  op2: {$0 * $0}\n)\n<\/pre>","status":"READY","tags":["rank3"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S2959","repo":"swift","name":"Statements should not end with semicolons","htmlDesc":"<p>The semicolon (<code>;<\/code>) is optional as a statement separator except in traditional <code>for<\/code> loops and when several statements are\ncombined on one line (which is a bad practice). For cleaner code, semicolons should be omitted.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint a;  \/\/ Noncompliant\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint a\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S2960","repo":"swift","name":"Operators should be surrounded by whitespace in function definitions","htmlDesc":"<p>Surrounding your operators with whitespace in operator declarations will help maintainers derive meaning from what might otherwise look like a\nmeaningless jumble of punctuation.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfunc &lt;*&gt;(a: MyClass, b: MyClass) -&gt; Boolean { \/\/ Noncompliant\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nfunc &lt;*&gt; (a: MyClass, b: MyClass) -&gt; Boolean {\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S2962","repo":"swift","name":"\"get\" should be omitted in read-only computed properties and subscripts","htmlDesc":"<p>For read-only computed properties and subscript declarations, the <code>get<\/code> keyword and its braces are optional, and should be omitted for\nthe sake of brevity.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nstruct Magic {\n  var number:Int {\n    get {  \/\/ Noncompliant\n      return 42\n    }\n  }\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nstruct Magic {\n  var number:Int {\n    return 42\n  }\n}\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S2963","repo":"swift","name":"\"self\" should only be used when required","htmlDesc":"<p>The use of <code>self<\/code> is optional except when in closure expressions, and when it's needed to distinguish between property names and\narguments. For the sake of brevity, <code>self<\/code> should be omitted when it's not strictly required.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nclass Car {\n  var color: Int\n\n  init(color: Int) {\n    self.color = color\n  }\n\n  func fade() {\n    self.color--  \/\/ Noncompliant\n  }\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nclass Car {\n  var color: Int\n\n  init(color: Int) {\n    self.color = color\n  }\n\n  func fade() {\n    color--\n  }\n}\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S2966","repo":"swift","name":"Optionals should not be force-unwrapped","htmlDesc":"<p>The point of declaring an optional variable is to make explicit the fact that it might contain no valid value, i.e. <code>nil<\/code>.\nForce-unwrapping an optional will lead to a runtime error if the optional does contain <code>nil<\/code>. Even if the value is tested first, it's still\nconsidered a bad practice to use force-unwrapping. Instead, optional binding or optional chaining should be used.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvar greeting: String?\n\n\/\/ ...\nprintln( \\(greeting!))  \/\/ Noncompliant; could cause a runtime error\n\nif greeting != nil {\n  println( \\(greeting!))  \/\/ Noncompliant; better but still not great\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvar greeting: String?\n\n\/\/ ...\nif let howdy = greeting {\n  println(howdy)\n}\n<\/pre>","status":"READY","tags":["rank1"],"langName":"Swift","params":[],"type":"BUG"},{"key":"swift:S2967","repo":"swift","name":"Implicitly unwrapped optionals should not be used","htmlDesc":"<p>The point of using an optional is to signal that the value may be <code>nil<\/code> and to provide graceful ways of dealing with it if it is\n<code>nil<\/code>. While implicitly unwrapped optionals still provide means of dealing with <code>nil<\/code> values, they also signal that the value\nwon't be <code>nil<\/code>, and unwrap it automatically. In addition to sending a decidedly mixed signal, this could lead to runtime errors if the\nvalue ever is <code>nil<\/code>. <\/p>\n<p>It is safest, and clearest to use either an optional or a plain type and avoid the boggy middle ground of implicitly unwrapped optionals.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvar greeting : String!  \/\/ Noncompliant\n\nprintln(greeting)  \/\/ At this point the value is nil. Runtime error results\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvar greeting : String?\n\nif let howdy = greeting {\n  println(howdy)\n}\n<\/pre>","status":"READY","tags":["rank1"],"langName":"Swift","params":[],"type":"BUG"},{"key":"swift:S2968","repo":"swift","name":"Function type parameters should come at the end of the parameter list","htmlDesc":"<p>Trailing closure syntax can only be used with the last argument to a function call. Place a function type parameter anywhere else in the list and\nyou limit the options of the caller.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfunc foo(p1: Int-&gt;Int, p2: Int){  \/\/ Noncompliant; p1 should come at the end\n  print(p1(p2))\n}\n\nfoo({a in a * 2}, 42) \/\/ Trailing closure syntax can't be used here\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nfunc foo(p2: Int, p1: Int-&gt;Int){\n  print(p1(p2))\n}\n\nfoo(42) {a in a * 2}\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Swift","params":[],"type":"CODE_SMELL"},{"key":"swift:S3087","repo":"swift","name":"Closure expressions should not be nested too deeply","htmlDesc":"<p>The point of using closure expressions is to clearly express a succinct bit of logic. Start nesting closure expressions too deeply and you create a\nlogic snarl that will likely snare both you and future maintainers.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the maximum depth of 2:<\/p>\n<pre>\nfoo(42) { (x: Int) in\n    bar(x) { (x: Int) in\n      foobar(x) { \/\/ Noncompliant\n        print(x * 42)\n      }\n      print(x + 42)\n    }\n    print(x - 42)\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nfunc multPlus(x:Int) {\n  foobar(x) {\n    print(x * 42)\n  }\n  print(x + 42)\n}\n\nfoo(42) { (x: Int) in\n    bar(x, multPlus)\n    print(x - 42)\n}\n<\/pre>","status":"READY","tags":["rank3"],"langName":"Swift","params":[{"key":"max","htmlDesc":"The maximum allowed closure expressions nesting depth.","defaultValue":"2","type":"INTEGER"}],"type":"CODE_SMELL"},{"key":"swift:S3110","repo":"swift","name":"Infix operators that end with \"=\" should update their left operands","htmlDesc":"<p>The conventional expectation of operators that end with <code>=<\/code>, such as <code>+=<\/code>, <code>-=<\/code>, <code>*=<\/code>, and so on, is\nthat the result of the operation will be assigned to the operand on the left-hand side of the operator.<\/p>\n<p>Define any other behavior and you almost guarantee that the users of your code will misunderstand and therefore misuse your operator.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfunc **= (p1:Int, p2:Int) -&gt; Int {   \/\/ Noncompliant. Change operator name or update value of first parameter\n    return p1 ** p2\n}\n\nfunc =&gt; (p1:Int, p2:Int) -&gt; Int {  \/\/ Compliant; doesn't end with '='\n    return p1 ** p1 ** p2\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nfunc **= (inout p1:Int, p2:Int) {\n    p1 = p1 ** p2\n}\n\nfunc =&gt; (p1:Int, p2:Int) -&gt; Int {\n    return p1 ** p1 ** p2\n}\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Swift","params":[],"type":"BUG"},{"key":"swift:S3111","repo":"swift","name":"Conditional compilation should not be used","htmlDesc":"<p>Conditional compilation is generally recognized as a bad practice that is occasionally necessary when dealing with platform-specific code. As much\nas possible, code should be refactored to minimize or eliminate conditionally-compiled, platform-specific code because even when necessary and\nwell-intentioned, such code segments can leave your codebase in a hopeless tangle.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\n#if os(OSX) \/\/ Noncompliant\n    let a = 2\n#else\n    let a = 3\n#endif\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Swift","params":[],"type":"CODE_SMELL"}],"language":"swift","languages":{"cs":"C#","java":"Java","js":"JavaScript","objc":"Objective C","php":"PHP","swift":"Swift","vbnet":"VB.NET","android":"Android"},"ranktag":"^rank\\d$"};
    </script>
    <script src="js/app.js"></script>
</body>
</html>
