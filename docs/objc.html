<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Coding Rules</title>

    <link rel="stylesheet" href="css/app.css">
</head>
<body>
    <div id="app"></div>
    <script>
        window.data = {"total":80,"p":1,"ps":500,"rules":[{"key":"common-objc:DuplicatedBlocks","repo":"common-objc","name":"Source files should not have any duplicated blocks","htmlDesc":"An issue is created on a file as soon as there is at least one block of duplicated code on this file","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"common-objc:FailedUnitTests","repo":"common-objc","name":"Failed unit tests should be fixed","htmlDesc":"Test failures or errors generally indicate that regressions have been introduced. Those tests should be handled as soon as possible to reduce the cost to fix the corresponding regressions.","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"BUG"},{"key":"objc:AssignmentInSubExpression","repo":"objc","name":"Assignments should not be made from within sub-expressions","htmlDesc":"<p>Assignments within sub-expressions are hard to spot and therefore make the code less readable. Ideally, sub-expressions should not have\nside-effects.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif ((str = cont.substring(pos1, pos2)).isEmpty()) {  \/\/ Noncompliant\n  \/\/...\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nstr = cont.substring(pos1, pos2);\nif (str.isEmpty()) {\n  \/\/...\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>Assignments explicitly enclosed in parentheses are ignored.<\/p>\n<pre>\nwhile ((run = keepRunning())) {\n  \/\/...\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 13.1 - Assignment operators shall not be used in expressions that yield a Boolean value <\/li>\n  <li> MISRA C++:2008, 6-2-1 - Assignment operators shall not be used in sub-expressions <\/li>\n  <li> MISRA C:2012, 13.4 - The result of an assignment operator should not be used <\/li>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/481.html\">MITRE, CWE-481<\/a> - Assigning instead of Comparing <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/nYFtAg\">CERT, EXP45-C.<\/a> - Do not perform assignments in selection statements <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/1gCTAw\">CERT, EXP51-J.<\/a> - Do not perform assignments in conditional expressions\n  <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/KQvhAg\">CERT, EXP19-CPP.<\/a> - Do not perform assignments in conditional expressions\n  <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/KYIyAQ\">CERT, MSC02-CPP.<\/a> - Avoid errors of omission <\/li>\n<\/ul>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:ClassName","repo":"objc","name":"Class names should comply with a naming convention","htmlDesc":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate.<\/p>\n<p>This rule allows to check that all class names (along with Objective-C interface, protocol and implementation names) match a provided regular\nexpression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With default provided regular expression <code>[A-Z][a-zA-Z0-9]++<\/code>:<\/p>\n<pre>\n\/\/ C++\nclass foo \/\/ Noncompliant\n{\n};\n\n\/\/ Objective-C\n@interface nonCompliant : NSObject\n@end\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\n\/\/ C++\nclass Foo \/\/ Compliant\n{\n};\n\n\/\/ Objective-C\n@interface Compliant : NSObject\n@end\n<\/pre>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:CommentMixedStyles","repo":"objc","name":"Comment styles \"\/\/\" and \"\/* ... *\/\" should not be mixed within a file","htmlDesc":"<p>Use either the <code>\/\/ ...<\/code> or <code>\/* ... *\/<\/code> comment syntax, but be consistent and do not mix them within the same file.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\n\/* Noncompliant; both comment syntaxes are used in the same file *\/\n\/\/ Foo\n\/* Bar *\/\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\n\/\/ Compliant; uniform comment syntax\n\/\/ Foo\n\/\/ Bar\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/DQBWB\">CERT, MSC55-J.<\/a> - Use comments consistently and in a readable fashion <\/li>\n<\/ul>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:ContinueUsage","repo":"objc","name":"\"continue\" should not be used","htmlDesc":"<p><code>continue<\/code> is an unstructured control flow statement. It makes code less testable, less readable and less maintainable. Structured\ncontrol flow statements such as <code>if<\/code> should be used instead.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint i;\nfor (i = 0; i &lt; 10; i++) {\n  if (i == 5) {\n    continue;  \/* Noncompliant *\/\n  }\n  printf(\"i = %d\\n\", i);\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint i;\nfor (i = 0; i &lt; 10; i++) {\n  if (i != 5) {\n    printf(\"i = %d\\n\", i);\n  }\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 14.5 - The continue statement shall not be used. <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:ElseIfWithoutElse","repo":"objc","name":"\"if ... else if\" constructs should end with \"else\" clauses","htmlDesc":"<p>This rule applies whenever an <code>if<\/code> statement is followed by one or more <code>else if<\/code> statements; the final <code>else if<\/code>\nshould be followed by an <code>else<\/code> statement.<\/p>\n<p>The requirement for a final <code>else<\/code> statement is defensive programming.<\/p>\n<p>The <code>else<\/code> statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is\nconsistent with the requirement to have a final <code>default<\/code> clause in a <code>switch<\/code> statement.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif (x == 0) {\n  doSomething();\n} else if (x == 1) {\n  doSomethingElse();\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif (x == 0) {\n  doSomething();\n} else if (x == 1) {\n  doSomethingElse();\n} else {\n  error();\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 14.10 - All if...else if constructs shall be terminated with an else clause. <\/li>\n  <li> MISRA C++:2008, 6-4-2 - All if...else if constructs shall be terminated with an else clause. <\/li>\n  <li> MISRA C:2012, 15.7 - All if...else if constructs shall be terminated with an else statement <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/YgE\">CERT, MSC01-C.<\/a> - Strive for logical completeness <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/JoIyAQ\">CERT, MSC01-CPP.<\/a> - Strive for logical completeness <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/PQHRAw\">CERT, MSC57-J.<\/a> - Strive for logical completeness <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:EmptyCompoundStatement","repo":"objc","name":"Nested blocks of code should not be left empty","htmlDesc":"<p>Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvoid foo()\n{\n  int x;\n  if (x == 42)\n  {                     \/* Noncompliant *\/\n    \/* do nothing *\/\n  }\n  else\n  {\n    printf(\"x != 42\");\n  }\n}\n\nvoid bar()\n{                       \/* Compliant - functions are not nested blocks *\/\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvoid foo()\n{\n  int x;\n  if (x != 42)\n  {                     \/* Compliant *\/\n    printf(\"x != 42\");\n  }\n}\n\n\/* ... *\/\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>When a block contains a comment, this block is not considered to be empty.<\/p>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:EnumPartialInitialization","repo":"objc","name":"\"enum\" members other than the first one should not be explicitly initialized unless all members are explicitly initialized","htmlDesc":"<p>If an enumerator list is given with no explicit initialization of members, then C\/C++ allocates a sequence of integers starting at zero for the\nfirst element and increasing by one for each subsequent element.<\/p>\n<p>An explicit initialization of the first element, as permitted by this rule, forces the allocation of integers to start at the given value. When\nadopting this approach it is essential to ensure that the initialization value used is small enough that no subsequent value in the list will exceed\nthe <code>int<\/code> storage used by enumeration constants.<\/p>\n<p>Explicit initialization of all items in the list, which is also permissible, prevents the mixing of automatic and manual allocation, which is error\nprone.<\/p>\n<p>However, it is then the responsibility of the developer to ensure that all values are in the required range, and that values are not\nunintentionally duplicated.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nenum color { red = 3, blue, green, yellow = 5 }; \/\/ Noncompliant; both green and yellow = 5\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nenum color { red = 3, blue = 4, green = 5, yellow = 5 }; \/\/ Compliant\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 9.3 - In an enumerator list, the \"=\" construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. <\/li>\n  <li> MISRA C++:2008, 8-5-3 - In an enumerator list, the = construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:FunctionComplexity","repo":"objc","name":"Functions should not be too complex","htmlDesc":"<p>The Cyclomatic Complexity of functions should not exceed a defined threshold. Complex code may perform poorly and can be difficult to test\nthoroughly.<\/p>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:IdentifierLongerThan31","repo":"objc","name":"Identifiers should not be longer than 31 characters","htmlDesc":"<p>In addition to being difficult to use, too-long variable names can limit code portability. The ISO standard requires that variable, type, function\nand label names be no more than 31 characters long. <\/p>\n<p>Note that 31 characters is an upper bound, rather than a length recommendation. Shorter names are better, as long as they're still\ncommunicative.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint this_is_a_very_long_identifier_that_definitely_should_be_renamed = 0;\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint reasonable_identifier = 0;\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 5.1 - Identifiers (internal and external) shall not rely on the significance of more than 31 character. <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/QAU\">CERT, DCL23-C.<\/a> - Guarantee that mutually visible identifiers are unique <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:IncAndDecMixedWithOtherOperators","repo":"objc","name":"Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression","htmlDesc":"<p>The use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:<\/p>\n<ul>\n  <li> It can significantly impair the readability of the code. <\/li>\n  <li> It introduces additional side effects into a statement, with the potential for undefined behavior. <\/li>\n  <li> It is safer to use these operators in isolation from any other arithmetic operators. <\/li>\n<\/ul>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nu8a = ++u8b + u8c--;\nfoo = bar++ \/ 4;\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<p>The following sequence is clearer and therefore safer:<\/p>\n<pre>\n++u8b;\nu8a = u8b + u8c;\nu8c--;\nfoo = bar \/ 4;\nbar++;\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 12.1 - Limited dependence should be placed on the C operator precedence rules in expressions. <\/li>\n  <li> MISRA C:2004, 12.13 - The increment (++) and decrement (--) operators should not be mixed with other operators in an expression. <\/li>\n  <li> MISRA C++:2008, 5-2-10 - The increment (++) and decrement (--) operator should not be mixed with other operators in an expression. <\/li>\n  <li> MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit <\/li>\n  <li> MISRA C:2012, 13.3 - A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects\n  other than that cause by the increment or decrement operator <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/ZwE\">CERT, EXP30-C.<\/a> - Do not depend on the order of evaluation for side effects\n  <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/fYAyAQ\">CERT, EXP50-CPP.<\/a> - Do not depend on the order of evaluation for side\n  effects <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/yQC7AQ\">CERT, EXP05-J.<\/a> - Do not follow a write by a subsequent write or read of the\n  same object within an expression <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:LineLength","repo":"objc","name":"Lines should not be too long","htmlDesc":"<p>Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.<\/p>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:NonEmptyCaseWithoutBreak","repo":"objc","name":"Switch cases should end with an unconditional \"break\" statement","htmlDesc":"<p>When the execution is not explicitly terminated at the end of a switch case, it continues to execute the statements of the following case. While\nthis is sometimes intentional, it often is a mistake which leads to unexpected behavior. <\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:  \/\/ Both 'doSomething()' and 'doSomethingElse()' will be executed. Is it on purpose ?\n    doSomething();\n  default:\n    doSomethingElse();\n    break;\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>This rule is relaxed in the following cases:<\/p>\n<pre>\nswitch (myVariable) {\n  case 0:                                \/\/ Empty case used to specify the same behavior for a group of cases.\n  case 1:\n    doSomething();\n    break;\n  case 2:                                \/\/ Use of return statement\n    return;\n  case 3:                                \/\/ Use of throw statement\n    throw 1;\n  case 4:                                \/\/ Use of continue statement\n    continue;\n  default:                               \/\/ For the last case, use of break statement is optional\n    doSomethingElse();\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 15.0 - The MISRA C <em>switch<\/em> syntax shall be used. <\/li>\n  <li> MISRA C:2004, 15.2 - An unconditional break statement shall terminate every non-empty switch clause <\/li>\n  <li> MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. <\/li>\n  <li> MISRA C++:2008, 6-4-5 - An unconditional throw or break statement shall terminate every non-empty switch-clause <\/li>\n  <li> MISRA C:2012, 16.1 - All switch statements shall be well-formed <\/li>\n  <li> MISRA C:2012, 16.3 - An unconditional break statement shall terminate every switch-clause <\/li>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/484.html\">MITRE, CWE-484<\/a> - Omitted Break Statement in Switch <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/YIFLAQ\">CERT, MSC17-C.<\/a> - Finish every set of statements associated with a case\n  label with a break statement <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/ZoFLAQ\">CERT, MSC18-CPP.<\/a> - Finish every set of statements associated with a case\n  label with a break statement <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/ewHAAQ\">CERT, MSC52-J.<\/a> - Finish every set of statements associated with a case\n  label with a break statement <\/li>\n<\/ul>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:OneStatementPerLine","repo":"objc","name":"Statements should be on separate lines","htmlDesc":"<p>For better readability, do not put more than one statement on a single line.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfoo(); bar(); \/\/ Noncompliant\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nfoo();\nbar();\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>Control flow statements with a single nested statement are ignored.<\/p>\n<pre>\nif (condition) doSomething();       \/\/ Compliant\nwhile (condition) doSomething();    \/\/ Compliant\n<\/pre>\n<p><code>case<\/code> or <code>default<\/code> statements containing a single statement and followed by <code>break<\/code> are ignored.<\/p>\n<pre>\nswitch (foo) {\n  case  0: doSomething(); break;    \/\/ Compliant\n  default: doSomething(); break;    \/\/ Compliant\n}\n<\/pre>\n<p>Statements enclosed in curly braces on the same line are ignored.<\/p>\n<pre>\nauto lambda = [](int x) { doSomething(x); return x; }; \/\/ Compliant\n<\/pre>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:PPMacroName","repo":"objc","name":"Macro names should comply with a naming convention","htmlDesc":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all macro\nnames match a provided regular expression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\n#define foo \/\/ Noncompliant\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\n#define FOO\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S100","repo":"objc","name":"Function names should comply with a naming convention","htmlDesc":"<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With default provided regular expression: <code>[a-z][a-zA-Z0-9]*<\/code>:<\/p>\n<pre>\nvoid DoSomething (void);\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvoid doSomething (void);\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1066","repo":"objc","name":"Collapsible \"if\" statements should be merged","htmlDesc":"<p>Merging collapsible <code>if<\/code> statements increases the code's readability.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif (condition1) {\n  if (condition2) {             \/\/ NonCompliant\n    \/* ... *\/\n  }\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif (condition1 &amp;&amp; condition2) { \/\/ Compliant\n  \/* ... *\/\n}\n<\/pre>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1067","repo":"objc","name":"Expressions should not be too complex","htmlDesc":"<p>The complexity of an expression is defined by the number of <code>&amp;&amp;<\/code>, <code>||<\/code> and <code>condition ? ifTrue : ifFalse<\/code>\noperators it contains.<\/p>\n<p>A single expression's complexity should not become too high to keep the code readable.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the default threshold value 3.<\/p>\n<pre>\nif (((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition4)) &amp;&amp; condition5) { ... }\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif ((myFirstCondition() || mySecondCondition()) &amp;&amp; myLastCondition()) { ... }\n<\/pre>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S107","repo":"objc","name":"Functions should not have too many parameters","htmlDesc":"<p>A long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many\nthings.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With a maximum number of 4 parameters:<\/p>\n<pre>\nvoid doSomething(int param1, int param2, int param3, int param4, int param5) {\n  ...\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvoid doSomething(int param1, int param2, int param3, int param4) {\n  ...\n}\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S109","repo":"objc","name":"Magic numbers should not be used","htmlDesc":"<p>A magic number is a number that comes out of nowhere, and is directly used in a statement. Magic numbers are often used, for instance to limit the\nnumber of iterations of a loops, to test the value of a property, etc.<\/p>\n<p>Using magic numbers may seem obvious and straightforward when you're writing a piece of code, but they are much less obvious and straightforward at\ndebugging time.<\/p>\n<p>That is why magic numbers must be demystified by first being assigned to clearly named variables before being used.<\/p>\n<p>-1, 0 and 1 are not considered magic numbers.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvoid doSomething() {\n  for(int i = 0; i &lt; 42; i++) {               \/\/ Noncompliant - 42 is a magic number\n    \/\/ ...\n  }\n\n  if (var == 42) {                            \/\/ Noncompliant - magic number\n    \/\/ ...\n  }\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\n#define STATUS_OK 42\n\nvoid doSomething() {\n  int maxIterations = 42;                     \/\/ Compliant - in a declaration\n  for(int i = 0; i &lt; maxIterations ; i++){    \/\/ Compliant\n    \/\/ ...\n  }\n\n  if (var == 0) {                             \/\/ Compliant - 0 is excluded\n    \/\/ ...\n  }\n\n  if (var == STATUS_OK) {                     \/\/ Compliant - number comes from a macro\n    \/\/ ...\n  }\n}\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1110","repo":"objc","name":"Redundant pairs of parentheses should be removed","htmlDesc":"<p>The use of parentheses, even those not required to enforce a desired order of operations, can clarify the intent behind a piece of code. But\nredundant pairs of parentheses could be misleading, and should be removed. <\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint x = (y \/ 2 + 1);   \/\/Compliant even if the parenthesis are ignored by the compiler\n\nif (a &amp;&amp; ((x+y &gt; 0))) {  \/\/ Noncompliant\n  \/\/...\n}\n\nreturn ((x + 1));  \/\/ Noncompliant\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint x = (y \/ 2 + 1);\n\nif (a &amp;&amp; (x+y &gt; 0)) {\n  \/\/...\n}\n\nreturn (x + 1);\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>When the result of an assignment is used as a condition, clang raises a warning to make sure the purpose was not to use <code>==<\/code> in place of\n<code>=<\/code>. Adding some parentheses around the assignment is a common way to silence this clang warning. So, no issue is raised in such case.<\/p>\n<pre>\nif ((x = 7)) {} \/\/ Compliant\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1116","repo":"objc","name":"Empty statements should be removed","htmlDesc":"<p>Empty statements, i.e. <code>;<\/code>, are usually introduced by mistake, for example because:<\/p>\n<ul>\n  <li> It was meant to be replaced by an actual statement, but this was forgotten. <\/li>\n  <li> There was a typo which lead the semicolon to be doubled, i.e. <code>;;<\/code>. <\/li>\n<\/ul>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvoid doSomething() {\n  ;                                                       \/\/ Noncompliant - was used as a kind of TODO marker\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvoid doSomething() {\n}\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>In the case of 2 consecutive semi-colons, if one of the two is part of a macro-definition then the issue is not raised.<\/p>\n<p>Example:<\/p>\n<pre>\n#define A(x) x;\n\nvoid fun() {\n  A(5);\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that\n  the first character following the null statement is a white-space character. <\/li>\n  <li> MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided\n  that the first character following the null statement is a white-space character. <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/NYA5\">CERT, MSC12-C.<\/a> - Detect and remove code that has no effect or is never\n  executed <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/SIIyAQ\">CERT, MSC12-CPP.<\/a> - Detect and remove code that has no effect <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/7gCTAw\">CERT, MSC51-J.<\/a> - Do not place a semicolon immediately following an if, for,\n  or while condition <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/i4FtAg\">CERT, EXP15-C.<\/a> - Do not place a semicolon on the same line as an if, for,\n  or while statement <\/li>\n<\/ul>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1131","repo":"objc","name":"Lines should not end with trailing whitespaces","htmlDesc":"<p>Trailing whitespaces are simply useless and should not stay in code. They may generate noise when comparing different versions of the same\nfile.<\/p>\n<p>If you encounter issues from this rule, this probably means that you are not using an automated code formatter - which you should if you have the\nopportunity to do so. <\/p>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1142","repo":"objc","name":"Functions should not contain too many return statements","htmlDesc":"<p>Having too many return statements in a function increases the function's essential complexity because the flow of execution is broken each time a\nreturn statement is encountered. This makes it harder to read and understand the logic of the function.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the default threshold of 3:<\/p>\n<pre>\nint fun() {\n  if (condition1) {\n    return 1;\n  } else {\n    if (condition2) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  return 0;\n}\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1151","repo":"objc","name":"\"switch case\" clauses should not have too many lines of code","htmlDesc":"<p>The <code>switch<\/code> statement should be used only to clearly define some new branches in the control flow. As soon as a <code>case<\/code>\nclause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of\n<code>case<\/code> clause should be extracted in a dedicated function.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the default threshold of 5:<\/p>\n<pre>\nswitch (myVariable) {\n  case 0: \/\/ 6 lines till next case\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    break;\n  case 1:\n  \/\/ ...\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nswitch (myVariable) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n  \/\/ ...\n}\n\/\/ ...\nvoid doSomething(){\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n}\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S116","repo":"objc","name":"Field names should comply with a naming convention","htmlDesc":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that field\nnames match a provided regular expression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the default regular expression <code>^[a-z][a-zA-Z0-9]*$<\/code>:<\/p>\n<pre>\nclass MyClass {\n  int my_field;\n};\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nclass MyClass {\n  int myField;\n};\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S117","repo":"objc","name":"Local variable and function parameter names should comply with a naming convention","htmlDesc":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all local\nvariable and function parameter names match a provided regular expression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the default regular expression <code>^[a-z][a-zA-Z0-9]*$<\/code>:<\/p>\n<pre>\nvoid doSomething(int my_param) {\n  int LOCAL;\n  ...\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvoid doSomething(int myParam) {\n  int local;\n  ...\n}\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>Loop counters and <code>const<\/code> variables are ignored by this rule.<\/p>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1186","repo":"objc","name":"Methods should not be empty","htmlDesc":"<p>There are several reasons for a method not to have a method body:<\/p>\n<ul>\n  <li> It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. <\/li>\n  <li> It is not yet, or never will be, supported. In this case an exception should be thrown in languages where that mechanism is available. <\/li>\n  <li> The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. <\/li>\n<\/ul>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvoid fun(int p1) {\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvoid fun(int p1) {\n  int a = doSomething(p1);\n  int threshold = 42;\n  if (a &gt; threshold) {\n    \/\/ ...\n  }\n}\n<\/pre>\n<p>or <\/p>\n<pre>\nvoid fun(int p1) {\n  \/\/ Intentionally unimplemented...\n}\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1199","repo":"objc","name":"Nested code blocks should not be used","htmlDesc":"<p>Nested code blocks can be used to create a new scope and restrict the visibility of the variables defined inside it. Using this feature in a method\ntypically indicates that the method has too many responsibilities, and should be refactored into smaller methods.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\npublic void evaluate(int operator) {\n  switch (operator) {\n    \/* ... *\/\n    case ADD: {                                \/\/ Noncompliant - nested code block '{' ... '}'\n        int a = stack.pop();\n        int b = stack.pop();\n        int result = a + b;\n        stack.push(result);\n        break;\n      }\n    \/* ... *\/\n  }\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\npublic void evaluate(int operator) {\n  switch (operator) {\n    \/* ... *\/\n    case ADD:                                  \/\/ Compliant\n      evaluateAdd();\n      break;\n    \/* ... *\/\n  }\n}\n\nprivate void evaluateAdd() {\n  int a = stack.pop();\n  int b = stack.pop();\n  int result = a + b;\n  stack.push(result);\n}\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S121","repo":"objc","name":"Control structures should use curly braces","htmlDesc":"<p>While not technically incorrect, the omission of curly braces can be misleading, and may lead to the introduction of errors during maintenance.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif (condition)  \/\/ Noncompliant\n  executeSomething();\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif (condition) {\n  executeSomething();\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement <\/li>\n  <li> MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement <\/li>\n  <li> MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement <\/li>\n  <li> MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement <\/li>\n  <li> MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/1QGMAg\">CERT, EXP19-C.<\/a> - Use braces for the body of an if, for, or while statement\n  <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/3wHEAw\">CERT, EXP52-J.<\/a> - Use braces for the body of an if, for, or while statement\n  <\/li>\n<\/ul>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1219","repo":"objc","name":"\"switch\" statements should not contain non-case labels","htmlDesc":"<p>Even if it is legal, mixing case and non-case labels in the body of a switch statement is very confusing and can even be the result of a typing\nerror.<\/p>\n<h2>Noncompliant Code Examples<\/h2>\n<p>Case 1, the code is syntactically correct but the behavior is not the expected one<\/p>\n<pre>\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  WEDNESDAY:   \/\/ instead of \"case WEDNESDAY\"\n    doSomething();\n    break;\n  ...\n}\n<\/pre>\n<p>Case 2, the code is correct and behaves as expected but is hardly readable <\/p>\n<pre>\nswitch (day) {\n  case MONDAY:\n    break;\n  case TUESDAY:\n    foo:for(int i = 0 ; i &lt; X ; i++) {\n         \/* ... *\/\n        break foo;  \/\/ this break statement doesn't relate to the nesting case TUESDAY\n         \/* ... *\/\n    }\n    break;\n    \/* ... *\/\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<p>Case 1<\/p>\n<pre>\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  case WEDNESDAY:\n    doSomething();\n    break;\n  ...\n}\n<\/pre>\n<p>Case 2<\/p>\n<pre>\nswitch (day) {\n  case MONDAY:\n    break;\n  case TUESDAY:\n    compute(args); \/\/ put the content of the labelled \"for\" statement in a dedicated method\n    break;\n\n    \/* ... *\/\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 15.0 - The MISRA C <em>switch<\/em> syntax shall be used. <\/li>\n  <li> MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. <\/li>\n  <li> MISRA C:2012, 16.1 - All switch statements shall be well-formed <\/li>\n<\/ul>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1226","repo":"objc","name":"Function parameters should not be reassigned","htmlDesc":"<p>While it is technically correct to assign to parameters from within function bodies, it is better to use temporary variables to store intermediate\nresults.<\/p>\n<p>Allowing parameters to be assigned to also reduces the code readability as developers will not be able to know whether the original parameter or\nsome temporary variable is being accessed without going through the whole function.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint glob = 0;\nvoid function (int a) {\n  a = glob; \/\/ Noncompliant\n  ...\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint glob = 0;\nvoid function (int a) {\n  int b = glob;\n  ...\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2012, 17.8 - A function parameter should not be modified <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1227","repo":"objc","name":"break statements should not be used except for switch cases","htmlDesc":"<p><code>break;<\/code> is an unstructured control flow statement which makes code harder to read.<\/p>\n<p>Ideally, every loop should have a single termination condition.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfor (element = list.first; element != null; element = element-&gt;next) { \/\/ First termination condition\n  if (!matches(element-&gt;value)) {                                      \/\/ Second termination condition\n    break; \/\/ Noncompliant\n  }\n\n  \/* ... *\/\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\n\/\/ Compliant\nfor (element = list.first; element != null &amp;&amp; matches(element-&gt;value); element = element-&gt;next) {\n  \/* ... *\/\n}\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1244","repo":"objc","name":"Floating point numbers should not be tested for equality","htmlDesc":"<p>Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a <code>float<\/code> or a <code>double<\/code> through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.<\/p>\n<p>Even simple floating point assignments are not simple:<\/p>\n<pre>\nfloat f = 0.1; \/\/ 0.100000001490116119384765625\ndouble d = 0.1; \/\/ 0.1000000000000000055511151231257827021181583404541015625\n<\/pre>\n<p>(Results will vary based on compiler and compiler settings);<\/p>\n<p>Therefore, the use of the equality (<code>==<\/code>) and inequality (<code>!=<\/code>) operators on <code>float<\/code> or <code>double<\/code> values\nis almost always an error. <\/p>\n<p>This rule checks for the use of direct and indirect equality\/inequailty tests on floats and doubles.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfloat myNumber = 3.146;\nif ( myNumber == 3.146 ) {  \/\/Noncompliant. Because of floating point imprecision, this will be false\n  \/\/ ...\n}\n\nif (myNumber &lt;= 3.146 &amp;&amp; mNumber &gt;= 3.146) { \/\/ Noncompliant indirect equality test\n  \/\/ ...\n}\n\nif (myNumber &lt; 4 || myNumber &gt; 4) { \/\/ Noncompliant indirect inequality test\n  \/\/ ...\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality. <\/li>\n  <li> MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality <\/li>\n<\/ul>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"BUG"},{"key":"objc:S1264","repo":"objc","name":"A \"while\" loop should be used instead of a \"for\" loop","htmlDesc":"<p>When only the condition expression is defined in a <code>for<\/code> loop, and the initialization and increment expressions are missing, a\n<code>while<\/code> loop should be used instead to increase readability. <\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfor (;condition;) { \/*...*\/ }\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nwhile (condition) { \/*...*\/ }\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S127","repo":"objc","name":"\"for\" loop stop conditions should be invariant","htmlDesc":"<p>A <code>for<\/code> loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and\nending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins. <\/p>\n<p>Stop conditions that are not invariant are slightly less efficient, as well as being difficult to understand and maintain, and likely lead to the\nintroduction of errors in the future.<\/p>\n<p>This rule tracks three types of non-invariant stop conditions:<\/p>\n<ul>\n  <li> When the loop counters are updated in the body of the <code>for<\/code> loop <\/li>\n  <li> When the stop condition depend upon a method call <\/li>\n  <li> When the stop condition depends on an object property, since such properties could change during the execution of the loop. <\/li>\n<\/ul>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfor (int i = 0; i &lt; 10; i++) {\n  ...\n  i = i - 1; \/\/ Noncompliant\n  ...\n}\nfor (int i = 0; i &lt; getMaximumNumber(); i++) {\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nfor (int i = 0; i &lt; 10; i++) {\n  ...\n}\nint stopCondition = getMaximumNumber();\nfor (int i = 0; i &lt; stopCondition; i++) {\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 13.6 - Numeric variables being used within a <em>for<\/em> loop for iteration counting shall not be modified in the body of the\n  loop. <\/li>\n  <li> MISRA C++:2008, 6-5-3 - The <em>loop-counter<\/em> shall not be modified within <em>condition<\/em> or <em>statement<\/em>. <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1301","repo":"objc","name":"\"switch\" statements should have at least 3 \"case\" clauses","htmlDesc":"<p><code>switch<\/code> statements are useful when there are many different cases depending on the value of the same expression.<\/p>\n<p>For just one or two cases however, the code will be more readable with <code>if<\/code> statements.<\/p>\n<p>Moreover, <code>if<\/code> statements are obviously more suitable when the condition of the <code>switch<\/code> is boolean.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif (variable == 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 15.5 - Every switch statement shall have at least one case clause. <\/li>\n  <li> MISRA C++:2008, 6-4-8 - Every switch statement shall have at least one case-clause. <\/li>\n  <li> MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S134","repo":"objc","name":"Control flow statements \"if\", \"for\", \"while\", \"switch\" and \"try\" should not be nested too deeply","htmlDesc":"<p>Nested <code>if<\/code>, <code>for<\/code>, <code>do<\/code>, <code>while<\/code>, <code>switch<\/code> and <code>try<\/code> statements is a key\ningredient for making what's known as \"Spaghetti code\".<\/p>\n<p>Such code is hard to read, refactor and therefore maintain.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the default threshold of 3:<\/p>\n<pre>\n  if (condition1) {                  \/\/ Compliant; depth = 1\n    \/* ... *\/\n    if (condition2) {                \/\/ Compliant; depth = 2\n      \/* ... *\/\n      for(int i = 0; i &lt; 10; i++) {  \/\/ Compliant; depth = 3, not exceeding the limit\n        \/* ... *\/\n        if (condition4) {            \/\/ Noncompliant; depth = 4\n          if (condition5) {          \/\/ Depth = 5, exceeding the limit, but issues are only reported on depth = 4\n            \/* ... *\/\n          }\n          return;\n        }\n      }\n    }\n  }\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow\nstatement.<\/p>\n<pre>\n  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)\/sizeof(ARR[0])); V++)\n\n  if (condition1) {       \/\/ Compliant; depth = 1\n    if (condition2) {     \/\/ Compliant; depth = 2\n      FOREACH(i, arr) {     \/\/ Compliant; depth = 3 (not 4)\n        if (condition3) {   \/\/ Noncompliant; depth = 4\n          \/* ... *\/\n        }\n      }\n    }\n  }\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S138","repo":"objc","name":"Functions\/methods should not have too many lines","htmlDesc":"<p>A function that grows too large tends to aggregate too many responsibilities.<\/p>\n<p>Such functions inevitably become harder to understand and therefore harder to maintain. <\/p>\n<p>Above a specific threshold, it is strongly advised to refactor into smaller functions which focus on well-defined tasks.<\/p>\n<p>Those smaller functions will not only be easier to understand, but also probably easier to test.<\/p>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S139","repo":"objc","name":"Comments should not be located at the end of lines of code","htmlDesc":"<p>This rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\na = b + c;   \/\/ This is a trailing comment that could be very very long\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\n\/\/ This very long comment is better placed before the line of code\na = b + c;\n<\/pre>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1479","repo":"objc","name":"\"switch\" statements should not have too many \"case\" clauses","htmlDesc":"<p>When <code>switch<\/code> statements have large sets of <code>case<\/code> clauses, it is usually an attempt to map two sets of data. A real map\nstructure would be more readable and maintainable, and should be used instead.<\/p>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1481","repo":"objc","name":"Unused local variables should be removed","htmlDesc":"<p>If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will\nnot wonder what the variable is used for.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint numberOfMinutes(int hours) {\n  int seconds = 0; \/\/ never used\n  return hours * 60;\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint numberOfMinutes(int hours) {\n  return hours * 60;\n}\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>No issue is raised on local variables having the attribute \"unused\", on exception handler parameters and on object declarations with non-empty\narguments.<\/p>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1642","repo":"objc","name":"\"struct\" names should comply with a naming convention","htmlDesc":"<p>Sharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all <code>struct<\/code> names match a provided\nregular expression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>Using the default regular expression <code>[A-Z][a-zA-Z0-9]*+<\/code>:<\/p>\n<pre>\nstruct myStruct {\n  int one;\n  int two;\n};\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nstruct MyStruct {\n  int one;\n  int two;\n};\n<\/pre>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1656","repo":"objc","name":"Variables should not be self-assigned","htmlDesc":"<p>There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvoid setValue(int value) {\n  value = value;\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvoid setValue(int value) {\n  this-&gt;value = value;\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/NYA5\">CERT, MSC12-C.<\/a> - Detect and remove code that has no effect or is never\n  executed <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/SIIyAQ\">CERT, MSC12-CPP.<\/a> - Detect and remove code that has no effect <\/li>\n<\/ul>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"BUG"},{"key":"objc:S1751","repo":"objc","name":"Jump statements should not be used unconditionally","htmlDesc":"<p>Having an unconditional <code>break<\/code>, <code>return<\/code>, <code>(@)throw<\/code> or <code>goto<\/code> in a loop renders it useless; the loop\nwill only execute once and the loop structure itself is simply wasted keystrokes.<\/p>\n<p>Having an unconditional <code>continue<\/code> in a loop can render the loop meaningless, or is itself wasted keystrokes, depending on where in the\nloop it occurs.<\/p>\n<p>Having an unconditional <code>return<\/code> anywhere other than at the end of a function or method simply renders all the rest of the code in the\nmethod useless.<\/p>\n<p>For these reasons, unconditional jump statements should never be used except for the final <code>return<\/code> in a function or method.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint i;\nfor (i = 0; i &lt; 10; ++i)\n{\n    printf(\"i is %d\", i);\n    break;  \/\/ loop only executes once\n}\n\nfor (i = 0; i &lt; 10; ++i)\n{\n    continue;\n    printf(\"i is %d\", i);  \/\/ this is never executed\n}\n\nfor (i = 0; i &lt; 10; ++i)\n{\n    printf(\"i is %d\", i);\n    continue;  \/\/ this is meaningless; the loop would continue anyway\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint i;\nfor (i = 0; i &lt; 10; ++i)\n{\n    printf(\"i is %d\", i);\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code. <\/li>\n  <li> MISRA C++:2008, 0-1-1 - A <em>project<\/em> shall not contain <em>unreachable code<\/em>. <\/li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code. <\/li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/NYA5\">CERT, MSC12-C.<\/a> - Detect and remove code that has no effect or is never\n  executed <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/SIIyAQ\">CERT, MSC12-CPP.<\/a> - Detect and remove code that has no effect <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"BUG"},{"key":"objc:S1763","repo":"objc","name":"Methods should not contain unreachable code","htmlDesc":"<p>Jump statements (<code>return<\/code>, <code>break<\/code>, <code>continue<\/code>, and <code>goto<\/code>) and <code>throw<\/code> expressions move\ncontrol flow out of the current code block. Typically, any statements in a block that come after a jump or <code>throw<\/code> are simply wasted\nkeystrokes lying in wait to confuse the unwary. <\/p>\n<p>Rarely, as illustrated below, code after a jump or <code>throw<\/code> is reachable. However, such code is difficult to understand, and should be\nrefactored. <\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint fun(int a) {\n  int i = 10;\n  return i + a;       \/\/ Noncompliant\n  i++;             \/\/ this is never executed\n}\n\nvoid foo(int a) {\n  if (a == 5) {\n    goto error;\n  } else {\n    \/\/ do the job\n  }\n  return;\n\n  error:\n    printf(\"don't use 5\"); \/\/ this is reachable but unreadable\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint fun(int a) {\n  int i = 10;\n  return i + a;\n}\n\nvoid foo(int a) {\n  if (a == 5) {\n    handleError();\n  } else {\n    \/\/ do the job\n  }\n  return;\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code <\/li>\n  <li> MISRA C++:2008, 0-1-1 - A project shall not contain unreachable code <\/li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code <\/li>\n  <li> MISRA C:2012, 2.1 - A project shall not contain unreachable code <\/li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code <\/li>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/561.html\">MITRE, CWE-561<\/a> - Dead Code <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/uQCSBg\">CERT, MSC56-J.<\/a> - Detect and remove superfluous code and values <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/NYA5\">CERT, MSC12-C.<\/a> - Detect and remove code that has no effect or is never\n  executed <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/OYIyAQ\">CERT, MSC07-CPP.<\/a> - Detect and remove dead code <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"BUG"},{"key":"objc:S1764","repo":"objc","name":"Identical expressions should not be used on both sides of a binary operator","htmlDesc":"<p>Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy\/paste\nerror and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical\noperators, having the same value on both sides of an operator yields predictable results, and should be simplified.<\/p>\n<p>This rule ignores <code>*<\/code>, <code>+<\/code>, and <code>=<\/code>. <\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif ( a == a ) { \/\/ always true\n  do_z();\n}\nif ( a != a ) { \/\/ always false\n  do_y();\n}\nif ( a == b &amp;&amp; a == b ) { \/\/ if the first one is true, the second one is too\n  do_x();\n}\nif (a == b || a == b ) { \/\/ if the first one is true, the second one is too\n  do_w();\n}\n\nif (5 \/ 5) { \/\/ always 1\n  do_v();\n}\nif (5 - 5) { \/\/ always 0\n  do_u();\n}\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>The following are ignored:<\/p>\n<ul>\n  <li> The expression <code>1 &lt;&lt; 1<\/code> <\/li>\n  <li> When an increment or decrement operator is used, ex: <code>*p++ == *p++<\/code> <\/li>\n  <li> Bitwise operators <code>|, &amp;, ^<\/code> <\/li>\n<\/ul>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/NYA5\">CERT, MSC12-C.<\/a> - Detect and remove code that has no effect or is never\n  executed <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/SIIyAQ\">CERT, MSC12-CPP.<\/a> - Detect and remove code that has no effect <\/li>\n  <li> <a href='\/coding_rules#rule_key=objc%3AS1656'>S1656<\/a> - Implements a check on <code>=<\/code>. <\/li>\n<\/ul>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"BUG"},{"key":"objc:S1772","repo":"objc","name":"Constants should come first in equality tests","htmlDesc":"<p>The result of the comparison is the same, regardless of whether the constant is on the left or right-hand side. But following this convention will\nhelp pinpoint the occasional error where <code>=<\/code> (assignment) is substituted for <code>==<\/code> (comparison). <\/p>\n<p>If the constant is on the right-hand side of the expression in such cases, the code will still compile and run - just not as expected. If the\nconstant is on the left-hand side, the error will be caught at the first attempt to compile.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif ( var == constant )\nif ( pointer == NULL )\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif ( constant == var )\nif ( NULL == pointer )\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1821","repo":"objc","name":"\"switch\" statements should not be nested","htmlDesc":"<p>Nested <code>switch<\/code> structures are difficult to understand because you can easily confuse the cases of an inner <code>switch<\/code> as\nbelonging to an outer statement. Therefore nested <code>switch<\/code> statements should be avoided.<\/p>\n<p>Specifically, you should structure your code to avoid the need for nested <code>switch<\/code> statements, but if you cannot, then consider moving\nthe inner <code>switch<\/code> to another function.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      \/\/ ...\n    case 2:\n      \/\/ ...\n    case 3:\n      switch (m) {  \/\/ Noncompliant\n    case 4:  \/\/ Bad indentation makes this particularly hard to read properly\n      \/\/ ...\n    case 5:\n      \/\/ ...\n    case 6:\n      \/\/ ...\n    }\n    case 4:\n      \/\/ ...\n    default:\n      \/\/ ...\n  }\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      \/\/ ...\n    case 2:\n      \/\/ ...\n    case 3:\n      int m2 = handle_m(m);\n    case 4:\n      \/\/ ...\n    default:\n      \/\/ ...\n  }\n}\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1854","repo":"objc","name":"Dead stores should be removed","htmlDesc":"<p>A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value\nonly to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error, it is at best a waste of resources.\nTherefore all calculated values should be used.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nvoid pow(int a, int b) {\n  if (b == 0) {\n    return 0;\n  }\n  int x = a;\n  for (int i = 1; i &lt; b; i++) {\n    x = x * a;  \/\/ Dead store because the last return statement should return x instead of returning a\n  }\n  return a;\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nvoid pow(int a, int b) {\n  if (b == 0) {\n    return 0;\n  }\n  int x = a;\n  for (int i = 1; i &lt; b; i++) {\n    x = x * a;\n  }\n  return x;\n}\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>This rule ignores:<\/p>\n<ul>\n  <li> variable declarations initializers <\/li>\n  <li> prefix and postfix increments and decrements <code>x++;<\/code> <\/li>\n  <li> null pointer assignments <code>x = NULL;<\/code> <\/li>\n  <li> self assignments (i.e. <code>x = x;<\/code>) <\/li>\n<\/ul>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/563.html\">MITRE, CWE-563<\/a> - Assignment to Variable without Use ('Unused Variable') <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/QYA5\">CERT, MSC13-C.<\/a> - Detect and remove unused values <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/S4IyAQ\">CERT, MSC13-CPP.<\/a> - Detect and remove unused values <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/uQCSBg\">CERT, MSC56-J.<\/a> - Detect and remove superfluous code and values <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/SIIyAQ\">CERT, MSC12-CPP.<\/a> - Detect and remove code that has no effect <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1874","repo":"objc","name":"Code annotated as deprecated should not be used","htmlDesc":"<p>Code annotated as deprecated should not be used since it will be removed sooner or later.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\n\/\/ C++14 attribute\n[[deprecated]]\nvoid fun();\n\n\/\/ GNU attribute\n__attribute__((deprecated))\nvoid fun();\n\n\/\/ Microsoft attribute\n__declspec(deprecated)\nvoid fun();\n\nvoid example() {\n  fun(); \/\/ Noncompliant\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/477.html\">MITRE, CWE-477<\/a> - Use of Obsolete Functions <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/KgAVAg\">CERT, MET02-J.<\/a> - Do not use deprecated or obsolete classes or methods <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S1986","repo":"objc","name":"Curly braces should not be used on interfaces without instance variables","htmlDesc":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that curly braces are omitted from interfaces with no instance\nvariables. <\/p>\n<p>Using curly braces in such a situation means that the reader of the code must pause to find the close curly brace before understanding that there\nare no variables. On the other hand, omitting the curly braces is a quick, clear indicator that there are no variables. <\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\n@interface Foo : NSObject { \/\/ Noncompliant\n}\n\n-(void) doSomething;\n\n@end\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\n@interface Foo : NSObject\n\n-(void) doSomething;\n\n@end\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S2193","repo":"objc","name":"\"for\" loop counters should not have essentially floating type","htmlDesc":"<p>When using a floating-point <code>for<\/code> loop counter, an accumulation of rounding errors may result in a mismatch between the expected and\nactual number of iterations.<\/p>\n<p>Even if floating-point loop counters appears to behave correctly on one implementation, it may give a different number of iterations on another\nimplementation.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfor (float counter = 0.0f; counter &lt; 1.0f; counter += 0.001f) {\n  ...\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nfor (int counter = 0; counter &lt; 1000; ++counter) {\n  ...\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 13.4 - The controlling expression of a for statement shall not contain any objects of floating type. <\/li>\n  <li> MISRA C++:2008, 6-5-1 - A <em>for<\/em> loop shall contain a single <em>loop-counter<\/em> which shall not have floating type. <\/li>\n  <li> MISRA C:2012, 14.1 - A <em>loop counter<\/em> shall not have essentially <em>floating type<\/em>. <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/uYIyAQ\">CERT, NUM09-J.<\/a> - Do not use floating-point variables as loop counters <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/AoG_\/\">CERT, FLP30-C.<\/a> - Do not use floating-point variables as loop counters <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"BUG"},{"key":"objc:S2342","repo":"objc","name":"Enumeration names should comply with a naming convention","htmlDesc":"<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all <code>enum<\/code> names match a provided regular\nexpression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With default provided regular expression <code>[A-Z][a-zA-Z0-9]++<\/code>:<\/p>\n<pre>\nenum someEnumeration { \/\/ Noncompliant\n};\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nenum SomeEnumeration {\n};\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S2343","repo":"objc","name":"Enumeration values should comply with a naming convention","htmlDesc":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all enumeration values match a provided regular\nexpression.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With default provided regular expression:<\/p>\n<pre>\nenum SomeEnumeration {\n    some  \/\/ Non-Compliant\n};\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nenum SomeEnumeration {\n    SOME\n};\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S2754","repo":"objc","name":"Declarations should not be empty","htmlDesc":"<p>Empty declarations are cruft; they (may) compile, but they violate the language standards, don't contribute anything of value, and clutter up the\nprogram. Like cobwebs, they should be swept away.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint;  \/\/ Noncompliant\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> ISO\/IEC 9899:2011, 6.7p2 <\/li>\n  <li> ISO\/IEC 14882:2011, 7p3. <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/NYA5\">CERT, MSC12-C.<\/a> - Detect and remove code that has no effect or is never\n  executed <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/SIIyAQ\">CERT, MSC12-CPP.<\/a> - Detect and remove code that has no effect <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S3358","repo":"objc","name":"Conditional operators should not be nested","htmlDesc":"<p>Just because you <em>can<\/em> do something, doesn't mean you should, and that's the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.<\/p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint max(int p1, int p2, int p3) {\n  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); \/\/ Noncompliant\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint max(int p1, int p2, int p3) {\n  if (p1 &gt; p2) {\n    return p1 &gt; p3 ? p1 : p3;\n  } else {\n    return p2 &gt; p3 ? p2 : p3;\n  }\n}\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S3458","repo":"objc","name":"Empty \"case\" clauses that fall through to the \"default\" should be omitted","htmlDesc":"<p>Empty <code>case<\/code> clauses that fall through to the default are useless. Whether or not such a <code>case<\/code> is present, the\n<code>default<\/code> clause will be invoked. Such <code>case<\/code>s simply clutter the code, and should be removed.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nswitch(ch)\n{\n  case 'a' :\n    handleA();\n    break;\n  case 'b' :\n    handleB();\n    break;\n  case 'c' :  \/\/ Noncompliant\n  default:\n    handleTheRest();\n    break;\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nswitch(ch)\n{\n  case 'a' :\n    handleA();\n    break;\n  case 'b' :\n    handleB();\n    break;\n  default:\n    handleTheRest();\n    break;\n}\n<\/pre>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S3485","repo":"objc","name":"Keywords should be used before arguments","htmlDesc":"<p>It may seem cleaner to omit keywords from your method declarations, but this is one time you should err on the side of verbosity. Omitting keywords\nin a declaration necessarily means that they'll be omitted from calls too. What results is code that will be impenetrable to maintainers. That's why\nit's considered best practice to always use keywords. This applies both to Objective-C-style parameters without keywords, and to C-style parameter\ndeclarations, which are deprecated.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\n@interface MyAction\n- (void)sendAction:(int)anAction :(int)flag;  \/\/ Noncompliant\n- (void)seekAction:(int)anAction, int flag;  \/\/ Noncompliant; hard on maintainers AND deprecated\n@end\n\nvoid test(MyAction* myAction) {\n  [myAction sendAction:1 :1];\n  [myAction sendAction:1 forAllCells:1]; \/\/ warning: 'MyAction' may not respond to 'sendAction:forAllCells:'\n  [myAction seekAction:1 :1];\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\n@interface MyAction\n- (void)sendAction:(int)anAction forAllCells:(int)flag;\n- (void)seekAction:(int)anAction forAllCells:(int)flag;\n@end\n\nvoid test(MyAction* myAction) {\n  [myAction sendAction:1 forAllCells:1];\n  [myAction seekAction:1 forAllCells:1];\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> <a href=\"https:\/\/developer.apple.com\/library\/mac\/documentation\/Cocoa\/Conceptual\/CodingGuidelines\/Articles\/NamingMethods.html\">Coding Guidelines\n  for Cocoa<\/a> - Naming Methods <\/li>\n<\/ul>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S3562","repo":"objc","name":"\"switch\" statements should cover all cases","htmlDesc":"<p>For completeness, a <code>switch<\/code> over the values of an <code>enum<\/code> must either address each value in the <code>enum<\/code> or contain\na <code>default<\/code> case. <code>switch<\/code> statements that are not over <code>enum<\/code>s must end with a <code>default<\/code> case.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f, int i) {\n  switch (f) {  \/\/ Noncompliant; no case for KIWI\n    case APPLE:\n      \/\/...\n    case GRAPE:\n      \/\/...\n    case 3: \/\/ Noncompliant; case value not in enum\n      \/\/ ...\n  }\n\n  switch (i) { \/\/ Noncompliant; no default\n    case 0:\n      \/\/ ...\n    case 1:\n      \/\/ ...\n  }\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      \/\/...\n    case GRAPE:\n      \/\/...\n    default:\n      \/\/ ...\n  }\n\n  switch (i) {\n    case 0:\n      \/\/ ...\n    case 1:\n      \/\/ ...\n    default:\n      \/\/ ...\n  }\n}\n<\/pre>\n<p>or<\/p>\n<pre>\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      \/\/...\n    case GRAPE:\n      \/\/...\n    case KIWI:\n      \/\/...\n  }\n\n  switch (i) {\n    case 0:\n    case 1:\n      \/\/ ...\n    default:\n      \/\/ ...\n  }\n}\n<\/pre>\n<h2>See also<\/h2>\n<ul>\n  <li> <a href='\/coding_rules#rule_key=objc%3ASwitchWithoutDefault'>SwitchWithoutDefault<\/a> <\/li>\n<\/ul>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S3744","repo":"objc","name":"Macros should not be redefined","htmlDesc":"<p>A macro definition should not be redefined without marking that intent specifically by un-defining it first.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\n#define A 1\n#define A 2\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\n#define A 1\n#undef A\n#define A 2\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>If the redefinition has the same value as the original one. This is consistent with most C compilers warnings.<\/p>\n<pre>\n#define A 1\n#define A 1\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S3935","repo":"objc","name":"\"case\" ranges should not be empty","htmlDesc":"<p>The GNU compiler extension that allows <code>case<\/code>s to be specified with ranges will only recognize ranges specified from a smaller value to\na larger value. Flip the order and the range will evaluate as empty.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nswitch (i) {\n  case 0:\n    \/\/...\n    break;\n  case 1 ... 2:\n    \/\/...\n    break;\n  case 5 ... 3: \/\/ Noncompliant\n    \/\/...\n    break;\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nswitch (i) {\n  case 0:\n    \/\/...\n    break;\n  case 1 ... 2:\n    \/\/...\n    break;\n  case 3 ... 5\n    \/\/...\n    break;\n<\/pre>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"BUG"},{"key":"objc:S3936","repo":"objc","name":"\"case\" ranges should cover multiple values","htmlDesc":"<p>The GNU compiler extension that allows <code>case<\/code>s to be specified with ranges should only be used when a range is actually needed. Use it\nwith the same number on both ends of the range, and you've either made a mistake because an actual range was intended, or you've used the syntax\ninappropriately in a way that is highly likely to confuse maintainers.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nswitch (i) {\n  case 0:\n    \/\/...\n    break;\n  case 1 ... 2:\n    \/\/...\n    break;\n  case 3 ... 3: \/\/ Noncompliant\n    \/\/...\n    break;\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nswitch (i) {\n  case 0:\n    \/\/...\n    break;\n  case 1 ... 2:\n    \/\/...\n    break;\n  case 3:\n    \/\/...\n    break;\n}\n<\/pre>\n<p>or<\/p>\n<pre>\nswitch (i) {\n  case 0:\n    \/\/...\n    break;\n  case 1 ... 2:\n    \/\/...\n    break;\n  case 3 ... 5:\n    \/\/...\n    break;\n}\n<\/pre>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S810","repo":"objc","name":"Appropriate char types should be used for character and integer values","htmlDesc":"<p>There are three distinct <code>char<\/code> types, (plain) <code>char<\/code>, <code>signed char<\/code> and <code>unsigned char<\/code>. <code>signed\nchar<\/code> and <code>unsigned char<\/code> should only be used for numeric data, and plain <code>char<\/code> should only be used for character data.\nSince it is implementation-defined, the signedness of the plain <code>char<\/code> type should not be assumed.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nsigned char a = 'a'; \/\/ Noncompliant, explicitly signed\nunsigned char b = '\\r'; \/\/ Noncompliant, explicitly unsigned\nchar c = 10; \/\/ Noncompliant\n\nunsigned char d = c; \/\/ Noncompliant, d is explicitly signed while c is not\nchar e = a; \/\/ Noncompliant, a is explicitly signed while e is not\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nchar a = 'a'; \/\/ Compliant, explicitly signed\nchar b = '\\r'; \/\/ Compliant, explicitly unsigned\nunsigned char c = 10; \/\/ Compliant, or\nsigned char c = 10; \/\/ Compliant\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 6.1 - The plain char type shall be used only for the storage and use of character values <\/li>\n  <li> MISRA C:2004, 6.2 - signed and unsigned char type shall be used only for the storage and use of number values <\/li>\n  <li> MISRA C++:2008, 5-0-11 - The plain char type shall only be used for the storage and use of character values <\/li>\n  <li> MISRA C++:2008, 5-0-12 - signed char and unsigned char type shall only be used for the storage and use of numeric values <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/-As\">CERT, INT07-C.<\/a> - Use only explicitly signed or unsigned char type for numeric\n  values <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/rYAyAQ\">CERT, INT07-CPP.<\/a> - Use only explicitly signed or unsigned char type for\n  numeric values <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/5AD7\">CERT, STR00-C.<\/a> - Represent characters using an appropriate type <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/IoEyAQ\">CERT, STR04-CPP.<\/a> - Use plain char for characters in the basic character set\n  <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/JABi\">CERT, STR04-C.<\/a> - Use plain char for characters in the basic character set\n  <\/li>\n<\/ul>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S835","repo":"objc","name":"Braces should be used to indicate and match the structure in the non-zero initialization of arrays and structures","htmlDesc":"<p>ISO\/IEC 14882:2003 [1] requires initializer lists for arrays, structures and union types to be enclosed in a single pair of braces (though the\nbehaviour if this is not done is undefined). The rule given here goes further in requiring the use of additional braces to indicate nested\nstructures.<\/p>\n<p>This forces the developer to explicitly consider and demonstrate the order in which elements of complex data types are initialized (e.g.\nmulti-dimensional arrays).<\/p>\n<p>The zero initialization of arrays or structures shall only be applied at the top level.<\/p>\n<p>The non-zero initialization of arrays or structures requires an explicit initializer for each element.<\/p>\n<p>A similar principle applies to structures, and nested combinations of structures, arrays and other types.<\/p>\n<p>Note also that all the elements of arrays or structures can be initialized (to zero or NULL) by giving an explicit initializer for the first\nelement only. If this method of initialization is chosen then the first element should be initialized to zero (or NULL), and nested braces need not be\nused.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint a1[3][2] = { 1, 2, 3, 4, 5, 6 }; \/\/ Noncompliant\nint a2[5] = { 1, 2, 3 }; \/\/ Noncompliant, partial initialization\nint a3[2][2] = { { }, { 1, 2 } }; \/\/ Noncompliant, zero initialization at sub-level\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint a1[3][2] = { { 1, 2 }, { 3, 4 }, { 5, 6 } }; \/\/ Compliant\nint a2[5] = { 1, 2, 3, 0, 0 }; \/\/ Compliant, Non-zero initialization\nint a2[5] = { 0 }; \/\/ Compliant, zero initialization\nint a3[2][2] = { }; \/\/ Compliant, zero initialization\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 9.2 - Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures. <\/li>\n  <li> MISRA C++:2008, 8-5-2 - Braces shall be used to indicate and match the structure in the nonzero initialization of arrays and structures. <\/li>\n  <li> MISRA C:2012, 9.2 - The initializer of an aggregate or union shall be enclosed in braces. <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S864","repo":"objc","name":"Limited dependence should be placed on operator precedence rules in expressions","htmlDesc":"<p>The rules of operator precedence are complicated and can lead to errors. For this reason, parentheses should be used for clarification in complex\nstatements. However, this does not mean that parentheses should be gratuitously added around every operation.<\/p>\n<p>Parentheses are not needed:<\/p>\n<ul>\n  <li> with a unary operator <\/li>\n  <li> when all the operators in an expression are the same <\/li>\n  <li> when only a single operator is involved <\/li>\n  <li> around the right-hand side of an assignment operator unless the right-hand side itself contains an assignment <\/li>\n<\/ul>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nx = a + b;\nx = a * -1;\nx = a + b + c;\nx = f ( a + b, c );\n\nx = a == b ? a : a - b; \/\/ Noncompliant\nx = a + b - c + d; \/\/ Noncompliant\nx = a * 3 + c + d; \/\/ Noncompliant\n\nif (a = f(b,c) == true) { ... } \/\/ Noncompliant; == evaluated first\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nx = a + b;\nx = a * -1;\nx = a + b + c;\nx = f ( a + b, c );\n\nx = ( a == b ) ? a : ( a - b );\nx = ( a + b ) - ( c + d );\nx = ( a * 3 ) + c + d;\n\nif ( (a = f(b,c)) == true) { ... }\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 12.1 - Limited dependence should be placed on C's operator precedence rules in expressions <\/li>\n  <li> MISRA C:2004, 12.2 - The value of an expression shall be the same under any order of evaluation that the standard permits. <\/li>\n  <li> MISRA C:2004, 12.5 - The operands of a logical &amp;&amp; or || shall be primary-expressions. <\/li>\n  <li> MISRA C++:2008, 5-0-1 - The value of an expression shall be the same under any order of evaluation that the standard permits. <\/li>\n  <li> MISRA C++:2008, 5-0-2 - Limited dependence should be placed on C++ operator precedence rules in expressions <\/li>\n  <li> MISRA C++:2008, 5-2-1 - Each operand of a logical &amp;&amp; or || shall be a postfix-expression. <\/li>\n  <li> MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/_wI\">CERT, EXP00-C.<\/a> - Use parentheses for precedence of operation <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/VoAyAQ\">CERT, EXP00-CPP.<\/a> - Use parentheses for precedence of operation <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/9wHEAw\">CERT, EXP53-J.<\/a> - Use parentheses for precedence of operation <\/li>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/783.html\">MITRE, CWE-783<\/a> - Operator Precedence Logic Error <\/li>\n<\/ul>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S867","repo":"objc","name":"Boolean operators should have boolean operands","htmlDesc":"<p>The use of operands with types other than <code>bool<\/code> with these operators is unlikely to be meaningful (or intended). This rule allows the\ndetection of such uses, which often occur because the logical operators (<code>&amp;&amp;<\/code>, <code>||<\/code> and <code>!<\/code>) can be easily\nconfused with the bitwise operators (<code>&amp;<\/code>, <code>|<\/code> and <code>~<\/code>).<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif ( 1 &amp;&amp; ( c &lt; d ) ) \/\/ Noncompliant\nif ( ( a &lt; b ) &amp;&amp; ( c + d ) ) \/\/ Noncompliant\nif ( u8_a &amp;&amp; ( c + d ) ) \/\/ Noncompliant\nif ( !0 ) \/\/ Noncompliant, always true\nif ( !ptr ) \/\/ Noncompliant\nif ( ( a &lt; b ) &amp;&amp; ( c &lt; d ) ) \/\/ Compliant\nif ( !false ) \/\/ Compliant\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif ( 1 != 0 &amp;&amp; ( c &lt; d ) ) \/\/ Compliant, but left operand is always true\nif ( ( a &lt; b ) &amp;&amp; ( c + d ) != 0 ) \/\/ Compliant\nif ( u8_a != 0 &amp;&amp; ( c + d ) != 0) \/\/ Compliant\nif ( 0 == 0 ) \/\/ Compliant, always true\nif ( ptr != NULL ) \/\/ Compliant\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 12.6 - The operands of logical operators (&amp;&amp;, || and !) should be effectively Boolean. Expressions that are effectively\n  Boolean should not be used as operands to operators other than (&amp;&amp;, || and !). <\/li>\n  <li> MISRA C++:2008, 5-3-1 - Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool. <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/KQHEAw\">CERT, EXP54-J.<\/a> - Understand the differences between bitwise and logical\n  operators <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"BUG"},{"key":"objc:S872","repo":"objc","name":"\"bool\" expressions should not be used as operands to built-in operators other than =, &&, ||, !, ==, !=, unary &, and the conditional operator","htmlDesc":"<p>The use of <code>bool<\/code> operands with other operators is unlikely to be meaningful (or intended). This rule allows the detection of such uses,\nwhich often occur because the logical operators (<code>&amp;&amp;<\/code>, <code>||<\/code> and <code>!<\/code>) can be easily confused with the bitwise\noperators (<code>&amp;<\/code>, <code>|<\/code> and <code>~<\/code>).<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nbool b1 = true;\nbool b2 = false;\nint8_t s8a;\nif ( b1 &amp; b2 ) \/\/ Noncompliant\nif ( ~b1 ) \/\/ Noncompliant\nif ( b1 &lt; b2 ) \/\/ Noncompliant\nif ( b1 ^ b2 ) \/\/ Noncompliant\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif ( b1 &amp;&amp; b2 )\nif ( !b1 )\nif ( b1 == false )\nif ( b1 == b2 )\nif ( b1 != b2 )\ns8a = b1 ? 3 : 7;\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>Operators <code>|=<\/code> and <code>&amp;=<\/code> are ignored when used with <code>bool<\/code> operands as a statement.<\/p>\n<pre>\nvoid test(bool b1, bool b2, int i1) {\n  b1 |= b2; \/\/ ignored\n  b1 &amp;= b2; \/\/ ignored\n  b1 &amp;= i1; \/\/ Noncompliant; right operand is not a bool\n  if (b1 |= b2) { \/\/ Noncompliant, \"|=\" on \"bool\" should not be used as expression\n    \/\/ ...\n  }\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C++:2008, 4-5-1 - Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator =,\n  the logical operators &amp;&amp;, ||, !, the equality operators == and !=, the unary &amp; operator, and the conditional operator. <\/li>\n<\/ul>","status":"READY","tags":["rank2"],"langName":"Objective-C","type":"BUG"},{"key":"objc:S873","repo":"objc","name":"\"enum\" values should not be used as operands to built-in operators other than [ ], =, ==, !=, unary &, and the relational operators <, <=, >, >=","htmlDesc":"<p>Enumerations have implementation-defined representation and so should not be used in arithmetic contexts.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nenum { COLOUR_0, COLOUR_1, COLOUR_2, COLOUR_COUNT } colour;\nif ( COLOUR_0 == colour ) { ... }\nif ( ( COLOUR_0 + COLOUR_1 ) == colour ) { ... } \/\/ Noncompliant, arithmetic used\nif ( colour &lt; COLOUR_COUNT ) { ... }\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C++:2008, 4-5-2 - Expressions with type enum shall not be used as operands to builtin operators other than the subscript operator [ ],\n  the assignment operator =, the equality operators == and !=, the unary &amp; operator, and the relational operators &lt;, &lt;=, &gt;, &gt;= <\/li>\n<\/ul>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S874","repo":"objc","name":"Bitwise operators should not be applied to signed operands","htmlDesc":"<p>Most bitwise operators (<code>~<\/code>, <code>&gt;&gt;<\/code>, <code>&gt;&gt;=<\/code>, <code>&amp;<\/code>, <code>&amp;=<\/code>, <code>^<\/code>,\n<code>^=<\/code>, <code>|<\/code>, and <code>|=<\/code>) have implementation-dependent results when performed on signed operands, and bitwise left shift\n(<code>&lt;&lt;<\/code> and <code>&lt;&lt;=<\/code>) has undefined behavior when performed on negative operands. Therefore bitwise operations should not\nbe performed on signed operands.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif ( ( uint16_a &amp; int16_b ) == 0x1234U )\nif ( ~int16_a == 0x1234U )\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif ( ( uint16_a | uint16_b ) == 0x1234U )\nif ( ~uint16_a == 0x1234U )\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>When used as bit flags, it is acceptable to use preprocessor macros as arguments to the &amp; and | operators even if the value is not explicitly\ndeclared as unsigned.<\/p>\n<pre>\nfd = open(file_name, UO_WRONLY | UO_CREAT | UO_EXCL | UO_TRUNC, 0600);\n<\/pre>\n<p>If the right-side operand to a shift operator is known at compile time, it is acceptable for the value to be represented with a signed type\nprovided it is positive.<\/p>\n<pre>\n#define SHIFT 24\nfoo = 15u &gt;&gt; SHIFT;\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 12.7 - Bitwise operators shall not be applied to operands whose underlying type is signed <\/li>\n  <li> MISRA C++:2008, 5-0-21 - Bitwise operators shall only be applied to operands of unsigned underlying type <\/li>\n  <li> MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/BoAD\">CERT, INT13-C.<\/a> - Use bitwise operators only on unsigned operands <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/vIAyAQ\">CERT, INT13-CPP.<\/a> - Use bitwise operators only on unsigned operands <\/li>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/682.html\">MITRE, CWE-682<\/a> - Incorrect Calculation <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"BUG"},{"key":"objc:S878","repo":"objc","name":"Comma operator should not be used","htmlDesc":"<p>The comma operator takes two expressions, executes them from left to right and returns the result of the second one. Use of this operator is\ngenerally detrimental to the readability and reliability of code, and the same effect can be achieved by other means.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\ni = a += 2, a + b;  \/\/ What's the value of i ?\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\na +=  2;\ni = a + b;\n<\/pre>\n<h2>Exceptions<\/h2>\n<p>Use of comma operator is tolerated in initialization and increment expressions of <code>for<\/code> loops.<\/p>\n<pre>\nfor(i = 0, j = 5; i &lt; 6; i++, j++) { ... }\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 12.10 - The comma operator shall not be used. <\/li>\n  <li> MISRA C++:2008, 5-18-1 - The comma operator shall not be used. <\/li>\n  <li> MISRA C:2012, 12.3 - The comma operator should not be used <\/li>\n<\/ul>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S883","repo":"objc","name":"Tests of non-Boolean values against zero should be explicit","htmlDesc":"<p>Where a data value is to be tested against zero then the test should be made explicit. The exception to this rule is when data represents a Boolean\nvalue, even though in C this will in practice be an integer.<\/p>\n<p>This rule is in the interests of clarity, and makes clear the distinction between integers and logical values.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nif ( x ) \/\/ Noncompliant, unless x is effectively Boolean data\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nif ( x == 0) \/\/ Compliant solution\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 13.2 - Tests of a value against zero should be made explicit, unless the operand is effectively Boolean. <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S886","repo":"objc","name":"The three expressions of a \"for\" statement should only be concerned with loop control","htmlDesc":"<p>The <code>for<\/code> statement provides a general-purpose looping facility. Using a restricted form of loop makes code easier to review and to\nanalyse.<\/p>\n<p>The three clauses of a for statement are the:<\/p>\n<ul>\n  <li> First clause which should\n    <ul>\n      <li> be empty, or <\/li>\n      <li> assign a value to the loop counter, or <\/li>\n      <li> define and initialize the loop counter (C99). <\/li>\n    <\/ul> <\/li>\n  <li> Second clause which should\n    <ul>\n      <li> be an expression that has no persistent side effects, and <\/li>\n      <li> not use objects that are modified in the for loop body. <\/li>\n    <\/ul> <\/li>\n  <li> Third clause which should\n    <ul>\n      <li> be an expression whose only persistent side effect is to modify the value of the loop counter, and <\/li>\n      <li> not use objects that are modified in the for loop body. <\/li>\n    <\/ul> <\/li>\n<\/ul>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nfor( int i = 0 ; i++ &lt; 10 ; i += 1 ) { \/\/ Noncompliant, loop counter is updated in the condition\n}\n\nfor( int i = 0 ; ; ) { \/\/ Noncompliant, initialized variable i is not used in the condition\n}\n\nfor( int i = 0 , j = 0 ; i &lt; 10 ; i += j) { \/\/ Noncompliant, j is modified in the body\n  j = i + 1;\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 13.5 - The three expressions of a for statement shall be concerned only with loop control. <\/li>\n  <li> MISRA C++:2008, 6-5-5 - A <em>loop-control-variable<\/em> other than the <em>loop-counter<\/em> shall not be modified within <em>condition<\/em>\n  or <em>expression<\/em>. <\/li>\n  <li> MISRA C:2012, 14.2 - A for loop shall be well-formed <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"BUG"},{"key":"objc:S920","repo":"objc","name":"Switch statement conditions should not have essentially boolean type","htmlDesc":"<p>When there is only a single condition to test, you have the option of using either a <code>switch<\/code> statement or an <code>if<\/code>-<code>else\nif<\/code>-<code>else<\/code> statement. For a larger set of potential values, a <code>switch<\/code> can be easier to read, but when the condition being\ntested is essentially boolean, then an <code>if<\/code>\/<code>else<\/code> statement should be used instead.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\n_Bool b = p &gt; 0;\nswitch (b) { \/\/ Noncompliant\n...\n}\nswitch (x == 0) { \/\/ Noncompliant\n...\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\n_Bool b = p &gt; 0;\nif (b) {\n...\n} else {\n...\n}\nif (x == 0) {\n...\n} else {\n...\n}\n<\/pre> \n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 15.4 - A switch expression shall not represent a value that is effectively Boolean <\/li>\n  <li> MISRA C++:2008, 6-4-7 - The condition of a switch statement shall not have bool type <\/li>\n  <li> MISRA C:2012, 16.7 - A switch-expression shall not have essentially Boolean type <\/li>\n<\/ul>","status":"READY","tags":["rank3"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S925","repo":"objc","name":"Recursion should not be used","htmlDesc":"<p>Recursion is a powerful tool, but it can be tricky to get right. Getting it wrong can lead to stack overflow errors and cause system problems. Even\nwhen you do get it right, recursive code can be difficult to understand, perhaps leading to maintenance problems in the future. Therefore recursion\nshould be avoided in general and used only with due deliberation and caution when it is strictly necessary.<\/p>\n<p>This rule checks for direct recursion (when a function calls itself).<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint pow(int num, int exponent) {\n  if (exponent &gt; 1) {\n    num = num * pow(num, exponent-1);  \/\/ Noncompliant; direct recursion\n  }\n  return num;\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint pow(int num, int exponent) {\n  int val = num;\n  while (exponent &gt; 0) {\n    val *= num;\n    --exponent;\n  }\n  return val;\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 16.2 - Functions shall not call themselves, either directly or indirectly. <\/li>\n  <li> MISRA C++:2008, 7-5-4 - Functions should not call themselves, either directly or indirectly. <\/li>\n  <li> MISRA C:2012, 17.2 - Functions shall not call themselves, either directly or indirectly <\/li>\n<\/ul>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:S935","repo":"objc","name":"Function exit paths should have appropriate return values","htmlDesc":"<p>Every call to a function with a non-void return type is expected to return some value. Including a return path in a non-void function that does not\nexplicitly return a value results in undefined behavior. <\/p>\n<p>Conversely, every call to a function with a void return type is expected to not return any value. Returning a value from a void function probably\nindicates a programming error.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint my_func (int a)\n{\n  if (a &gt; 100)\n  {\n    return; \/\/ Noncompliant\n  }\n\n  if (a &gt; 80)\n  {\n    throw new Exception(); \/\/ Compliant\n  }\n\n  \/\/ Noncompliant\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint my_func (int a)\n{\n  if (a &gt; 100)\n  {\n    return 12;\n  }\n\n  if (a &gt; 80)\n  {\n    throw new Exception();\n  }\n\n  return a;\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 16.8 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression <\/li>\n  <li> MISRA C++:2008, 8-4-3 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression\n  <\/li>\n  <li> MISRA C:2012, 17.4 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression <\/li>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/394.html\">MITRE, CWE-394<\/a> - Unexpected Status Code or Return Value <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/goCGAg\">CERT, MSC37-C.<\/a> - Ensure that control never reaches the end of a non-void\n  function <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/ZoCKC\">CERT, MSC52-CPP.<\/a> - Value-returning functions must return a value from all\n  exit paths <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/dICKC\">CERT, MSC53-CPP.<\/a> - Do not return from a function declared [[noreturn]] <\/li>\n<\/ul>","status":"READY","tags":["rank4"],"langName":"Objective-C","type":"BUG"},{"key":"objc:SingleDeclarationPerStatement","repo":"objc","name":"Init-declarator-lists and member-declarator-lists should consist of single init-declarators and member-declarators respectively","htmlDesc":"<p>Where multiple declarators appear in the same declaration the type of an identifier may not meet developer expectations.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nint i1; int j1; \/\/ Compliant, but not preferred\nint i2, *j2; \/\/ Noncompliant\nint *i3,\n&amp;j3 = i2; \/\/ Noncompliant\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nint i1;\nint j1;\nint i2;\nint *j2;\nint *i3;\nint &amp;j3 = i2;\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator\n  respectively <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/7wHEAw\">CERT, DCL52-J.<\/a> - Do not declare more than one variable per declaration\n  <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/VgU\">CERT, DCL04-C.<\/a> - Do not declare more than one variable per declaration <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/fAAhAQ\">CERT, DCL04-CPP.<\/a> - Do not declare more than one variable per declaration\n  <\/li>\n<\/ul>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:SingleGotoOrBreakPerIteration","repo":"objc","name":"Loops should not have more than one \"break\" or \"goto\" statement","htmlDesc":"<p>Restricting the number of exits from a loop is done in the interests of good structured programming. One <code>break<\/code> or <code>goto<\/code>\nstatement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<p>With the default threshold of 1:<\/p>\n<pre>\nfor (int i = 0; i &lt; 10; i++) {\n  if (...) {\n    break;      \/\/  Compliant\n  }\n  else if (...) {\n    break;      \/\/  Non-compliant - second jump from loop\n  }\n  else {\n    ...\n  }\n}\nwhile (...) {\n  if (...) {\n    break;      \/\/ Compliant\n  }\n  if (...) {\n    break;      \/\/ Non-compliant - second jump from loop\n  }\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nfor (int i = 0; i &lt; 10; i++) {\n  if (...) {\n    break;      \/\/  Compliant\n  }\n}\nwhile (...) {\n  if (...) {\n    break;    \/\/ Compliant\n  }\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. <\/li>\n  <li> MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. <\/li>\n  <li> MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement <\/li>\n<\/ul>","status":"READY","tags":["rank5"],"langName":"Objective-C","type":"CODE_SMELL"},{"key":"objc:SwitchWithoutDefault","repo":"objc","name":"\"switch\" statements should end with \"default\" clauses","htmlDesc":"<p>The requirement for a final <code>default<\/code> clause is defensive programming. The clause should either take appropriate action, or contain a\nsuitable comment as to why no action is taken. When the <code>switch<\/code> covers all current values of an <code>enum<\/code> - and especially when it\ndoesn't - a <code>default<\/code> case should still be used because there is no guarantee that the <code>enum<\/code> won't be extended.<\/p>\n<h2>Noncompliant Code Example<\/h2>\n<pre>\nswitch (param) { \/\/ Noncompliant - default clause is missing\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n<\/pre>\n<h2>Compliant Solution<\/h2>\n<pre>\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n  default:\n    doDefault();\n    break;\n}\n<\/pre>\n<h2>See<\/h2>\n<ul>\n  <li> MISRA C:2004, 15.0 - The MISRA C <em>switch<\/em> syntax shall be used. <\/li>\n  <li> MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause <\/li>\n  <li> MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. <\/li>\n  <li> MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause <\/li>\n  <li> MISRA C:2012, 16.1 - All switch statements shall be well-formed <\/li>\n  <li> MISRA C:2012, 16.4 - Every <em>switch<\/em> statement shall have a <em>default<\/em> label <\/li>\n  <li> MISRA C:2012, 16.5 - A <em>default<\/em> label shall appear as either the first or the last <em>switch label<\/em> of a <em>switch<\/em> statement\n  <\/li>\n  <li> <a href=\"http:\/\/cwe.mitre.org\/data\/definitions\/478.html\">MITRE, CWE-478<\/a> - Missing Default Case in Switch Statement <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/YgE\">CERT, MSC01-C.<\/a> - Strive for logical completeness <\/li>\n  <li> <a href=\"https:\/\/www.securecoding.cert.org\/confluence\/x\/JoIyAQ\">CERT, MSC01-CPP.<\/a> - Strive for logical completeness <\/li>\n<\/ul>\n<h3>See also<\/h3>\n<ul>\n  <li> <a href='\/coding_rules#rule_key=objc%3AS3562'>S3562<\/a> <\/li>\n<\/ul>","status":"READY","tags":["rank1"],"langName":"Objective-C","type":"CODE_SMELL"}],"language":"objc","languages":{"cs":"C#","java":"Java","js":"JavaScript","objc":"Objective C","php":"PHP","swift":"Swift","vbnet":"VB.NET"}};
    </script>
    <script src="js/app.js"></script>
</body>
</html>
